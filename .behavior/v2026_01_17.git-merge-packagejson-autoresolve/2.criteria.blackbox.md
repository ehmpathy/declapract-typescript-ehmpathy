# blackbox criteria = experience bounds

## usecase.1 = resolve version conflicts (same dep updated in both branches)

given('a package.json merge conflict where the same dependency was updated in both branches')
  when('the merge resolution is invoked')
    then('the higher semver version is selected')
      sothat('users always get the latest compatible version without manual comparison')
    then('the resolved package.json is valid json')
    then('the conflict markers are removed')

given('a package.json with multiple dependencies that have version conflicts')
  when('the merge resolution is invoked')
    then('each dependency resolves independently to its higher version')
      sothat('users can resolve all conflicts in one pass')

given('a version conflict with pre-release versions like "1.0.0-beta.1" vs "1.0.0"')
  when('the merge resolution is invoked')
    then('semver precedence rules are honored (1.0.0 > 1.0.0-beta.1)')
      sothat('stable releases are preferred over pre-releases when appropriate')

given('a version conflict with caret/tilde ranges like "^1.2.3" vs "~1.3.0"')
  when('the merge resolution is invoked')
    then('versions are compared WITHOUT qualifiers (1.2.3 vs 1.3.0)')
    then('the entry with the higher base version wins as-is ("~1.3.0")')
      sothat('users get the higher version with its original qualifier preserved')


## usecase.2 = union additions (dep added in one branch, absent in base)

given('a package.json merge conflict where a dependency was added in one branch but did not exist in base')
  when('the merge resolution is invoked')
    then('the new dependency is preserved in the result')
      sothat('new dependencies from feature branches are not lost')

given('a package.json merge conflict where different dependencies were added in each branch')
  when('the merge resolution is invoked')
    then('both new dependencies appear in the result')
      sothat('parallel feature work is unionized correctly')


## usecase.3 = honor removal intent (dep removed in one branch, kept in other)

given('a package.json merge conflict where a dependency was explicitly removed in one branch')
  when('the merge resolution is invoked')
    then('the dependency is removed in the result')
      sothat('intentional cleanup is preserved, not reverted')

given('a package.json merge conflict where a dependency was removed in one branch and updated in another')
  when('the merge resolution is invoked')
    then('the removal intent takes precedence')
      sothat('explicit deletions are honored over implicit updates')


## usecase.4 = handle dependency sections correctly

given('conflicts across multiple sections: dependencies, devDependencies, peerDependencies, optionalDependencies')
  when('the merge resolution is invoked')
    then('each section is resolved independently with the same rules')
      sothat('the logic applies uniformly regardless of dependency type')

given('a dependency that moved from devDependencies to dependencies across branches')
  when('the merge resolution is invoked')
    then('the dependency appears in the correct final section without duplication')
      sothat('section migrations are handled cleanly')


## usecase.5 = scope limited to dependency sections only

given('a package.json merge conflict that includes changes to non-dependency fields like "name", "version", "scripts"')
  when('the merge resolution is invoked')
    then('non-dependency fields are LEFT WITH CONFLICT MARKERS')
      sothat('semantic changes to project metadata require human review')
    then('dependency sections (dependencies, devDependencies, peerDependencies, optionalDependencies) ARE resolved')
      sothat('users get partial resolution benefit for the dependency portions')

given('a package.json with ONLY non-dependency field conflicts')
  when('the merge resolution is invoked')
    then('the tool exits with non-zero (conflict remains)')
      sothat('git knows the merge was not fully resolved')


## usecase.6 = edge cases and error scenarios

given('a package.json with invalid json syntax in one or both branches')
  when('the merge resolution is invoked')
    then('an error is raised with a clear message that identifies which branch has invalid json')
      sothat('users can fix syntax before resolution')

given('a package.json with non-semver version strings like "latest" or "file:../local"')
  when('the merge resolution is invoked')
    then('non-semver versions are preserved as-is without comparison')
      sothat('special version specifiers are not mangled')

given('a package.json with workspace protocol versions like "workspace:^"')
  when('the merge resolution is invoked')
    then('workspace versions are handled correctly')
      sothat('monorepo setups are supported')


## usecase.7 = git integration via .gitattributes

given('a user wants automatic package.json merge resolution for their repo')
  when('they configure .gitattributes with the custom merge driver')
    then('all future package.json merges use the autoresolve logic')
      sothat('no manual invocation is required per-merge')
    then('the configuration is portable across clones')
      sothat('team members automatically benefit without local setup')

given('a repo with .gitattributes configured for package.json merge driver')
  when('a merge conflict occurs in package.json')
    then('the custom driver is invoked automatically by git')
      sothat('the experience is seamless and invisible when it works')

given('a repo WITHOUT .gitattributes configuration')
  when('a user wants to resolve a package.json conflict manually')
    then('they can invoke the tool directly on the conflicted file')
      sothat('the tool is usable both automatically and on-demand')

given('a git repository NOT in a merge conflict state')
  when('the user invokes the resolution tool directly')
    then('a clear message indicates no conflicts to resolve')
      sothat('users understand why no action was taken')


## boundary conditions

### version comparison
- qualifiers (^, ~, >=, etc.) are STRIPPED for comparison, but the WINNER keeps its original format
  - e.g., `^1.2.3` vs `~1.4.0` → compare `1.2.3` vs `1.4.0` → winner is `~1.4.0` (kept as-is)
- version strings with >= 3 parts (1.2.3.4) are handled gracefully
- version strings with build metadata (1.0.0+build.123) follow semver rules
- pre-release versions follow semver precedence (1.0.0 > 1.0.0-beta)

### scope
- ONLY dependency sections are resolved: dependencies, devDependencies, peerDependencies, optionalDependencies
- non-dependency fields (name, version, scripts, etc.) are LEFT WITH CONFLICT MARKERS
- lockfile (package-lock.json, yarn.lock, pnpm-lock.yaml) is NOT auto-resolved
  - sothat users regenerate it after the merge to ensure integrity

### behavior
- NO dry-run mode — the tool always writes the result
- empty dependency sections ({}) are preserved, not removed
- dependency order within sections may change (alphabetization is acceptable)
