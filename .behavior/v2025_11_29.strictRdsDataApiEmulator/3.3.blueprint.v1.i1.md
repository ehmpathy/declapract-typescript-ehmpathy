# Blueprint: Strict RDS Data API Emulator

## Wish
> We have a local RDS Data API emulator that is as strict as the real AWS RDS Data API

## Problem Statement

The current `koxudaxi/local-data-api` emulator uses JDBC (`ENGINE: PostgreSQLJDBC`) which automatically infers parameter types. For example, when you pass a UUID string like `"627ea5ae-3228-4fbf-9590-4735f77869f7"`, JDBC recognizes it as a UUID and binds it correctly.

The real AWS RDS Data API does NOT do this inference. Without an explicit `typeHint: 'UUID'`, it sends the value as plain `TEXT`, causing PostgreSQL to fail with:
```
ERROR: operator does not exist: uuid = text
```

This creates a gap where tests pass locally but fail in production.

---

## Chosen Solution

Build a custom Node.js-based RDS Data API emulator that:
1. Uses `node-postgres` (pg) driver instead of JDBC
2. Explicitly sets PostgreSQL type OIDs based on `typeHint` only
3. Defaults to `TEXT` type when no hint is provided (matching AWS behavior)

---

## Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                     Docker Compose                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────────────┐         ┌──────────────────────────────┐  │
│  │                  │         │                              │  │
│  │    PostgreSQL    │◄────────│   strict-rds-data-api        │  │
│  │  homeservicesdb  │   pg    │   (Node.js + pg driver)      │  │
│  │    port 5432     │         │   - NO type inference        │  │
│  │                  │         │   - Requires typeHint        │  │
│  └────────┬─────────┘         └───────────┬──────────────────┘  │
│           │                               │                      │
└───────────┼───────────────────────────────┼──────────────────────┘
            │                               │
       port 7821                       port 7823
            │                               │
            ▼                               ▼
    ┌───────────────┐              ┌────────────────┐
    │  Direct JDBC  │              │  RDS Data API  │
    │   (existing)  │              │ (strict mode)  │
    └───────────────┘              └────────────────┘
```

---

## Implementation

### Project Structure

```
packages/strict-rds-data-api/
├── src/
│   ├── index.ts              # Entry point
│   ├── server.ts             # Express HTTP server
│   ├── handlers/
│   │   └── executeStatement.ts   # POST / handler
│   ├── executor.ts           # SQL execution with strict typing
│   ├── typeMapping.ts        # typeHint → PostgreSQL OID mapping
│   ├── parameterParser.ts    # Parse RDS Field → JS value
│   └── resultFormatter.ts    # Format pg results → RDS response
├── Dockerfile
├── package.json
└── tsconfig.json
```

### Core Type Mapping

```typescript
// src/typeMapping.ts

// PostgreSQL type OIDs (from pg_type catalog)
export const PG_TYPE_OIDS = {
  TEXT: 25,
  UUID: 2950,
  INT4: 23,
  INT8: 20,
  FLOAT8: 701,
  NUMERIC: 1700,
  BOOL: 16,
  JSON: 114,
  JSONB: 3802,
  TIMESTAMP: 1114,
  TIMESTAMPTZ: 1184,
  DATE: 1082,
  TIME: 1083,
} as const;

// Map RDS Data API typeHint to PostgreSQL OID
// STRICT: Only use typeHint, never infer from value
export const typeHintToOid = (typeHint?: string): number => {
  switch (typeHint) {
    case 'UUID':
      return PG_TYPE_OIDS.UUID;
    case 'DATE':
      return PG_TYPE_OIDS.DATE;
    case 'TIME':
      return PG_TYPE_OIDS.TIME;
    case 'TIMESTAMP':
      return PG_TYPE_OIDS.TIMESTAMP;
    case 'DECIMAL':
      return PG_TYPE_OIDS.NUMERIC;
    case 'JSON':
      return PG_TYPE_OIDS.JSONB;
    default:
      // STRICT: Default to TEXT, no inference
      return PG_TYPE_OIDS.TEXT;
  }
};
```

### SQL Executor

```typescript
// src/executor.ts
import { Client, QueryConfig } from 'pg';
import { typeHintToOid } from './typeMapping';
import { SqlParameter, Field } from './types';

// Extract value from RDS Field type
const extractValue = (field: Field): unknown => {
  if (field.isNull) return null;
  if (field.stringValue !== undefined) return field.stringValue;
  if (field.longValue !== undefined) return field.longValue;
  if (field.doubleValue !== undefined) return field.doubleValue;
  if (field.booleanValue !== undefined) return field.booleanValue;
  if (field.blobValue !== undefined) return Buffer.from(field.blobValue);
  return null;
};

export const executeStatement = async (
  client: Client,
  sql: string,
  parameters: SqlParameter[],
): Promise<QueryResult> => {
  // Convert :paramN placeholders to $N for pg driver
  const pgSql = sql.replace(/:param(\d+)/g, '$$$1');

  // Extract values and build type OID array
  const values = parameters.map((p) => extractValue(p.value));
  const types = parameters.map((p) => typeHintToOid(p.typeHint));

  const queryConfig: QueryConfig = {
    text: pgSql,
    values,
    // Explicitly set parameter types - NO inference
    types: types,
  };

  return client.query(queryConfig);
};
```

### HTTP Server

```typescript
// src/server.ts
import express from 'express';
import { Client } from 'pg';
import { executeStatement } from './executor';
import { formatResponse } from './resultFormatter';

const app = express();
app.use(express.json());

// Connection pool keyed by resourceArn + secretArn
const clients = new Map<string, Client>();

const getClient = async (resourceArn: string, secretArn: string): Promise<Client> => {
  const key = `${resourceArn}:${secretArn}`;
  if (!clients.has(key)) {
    const client = new Client({
      host: process.env.POSTGRES_HOST || 'postgres',
      port: parseInt(process.env.POSTGRES_PORT || '5432'),
      user: process.env.POSTGRES_USER || 'postgres',
      password: process.env.POSTGRES_PASSWORD,
      database: process.env.POSTGRES_DB || 'postgres',
    });
    await client.connect();
    clients.set(key, client);
  }
  return clients.get(key)!;
};

// RDS Data API uses POST to root with X-Amz-Target header
app.post('/', async (req, res) => {
  const target = req.headers['x-amz-target'];

  if (target === 'RdsDataService.ExecuteStatement') {
    const { resourceArn, secretArn, database, sql, parameters = [] } = req.body;

    try {
      const client = await getClient(resourceArn, secretArn);

      // Set search_path if database specified
      if (database) {
        await client.query(`SET search_path TO ${database}, public`);
      }

      const result = await executeStatement(client, sql, parameters);
      res.json(formatResponse(result, req.body.includeResultMetadata));
    } catch (error) {
      res.status(400).json({
        __type: 'DatabaseErrorException',
        message: error.message,
      });
    }
  } else {
    res.status(400).json({
      __type: 'BadRequestException',
      message: `Unsupported operation: ${target}`,
    });
  }
});

export { app };
```

### Dockerfile

```dockerfile
FROM node:20-alpine

WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production

COPY dist/ ./dist/

ENV NODE_ENV=production
EXPOSE 80

CMD ["node", "dist/index.js"]
```

---

## Docker Compose Integration

Replace `koxudaxi/local-data-api` with the strict emulator:

```yaml
# provision/docker/integration-test-db/docker-compose.yml
version: '3'
services:
  postgres:
    build:
      context: .
      dockerfile: build-image.dockerfile
    container_name: homeservicesdb
    command: postgres -c 'max_connections=500'
    ports:
      - 7821:5432
    environment:
      POSTGRES_PASSWORD: a-secure-password
      POSTGRES_DB: homeservicesdb
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -U postgres -d homeservicesdb']
      interval: 5s
      timeout: 5s
      retries: 5

  rds-data-api:
    build:
      context: ../../packages/strict-rds-data-api
      dockerfile: Dockerfile
    container_name: homeservicesdb-rds-data-api
    depends_on:
      postgres:
        condition: service_healthy
    ports:
      - 7823:80
    environment:
      POSTGRES_HOST: postgres
      POSTGRES_PORT: 5432
      POSTGRES_USER: svc_home_services_user
      POSTGRES_PASSWORD: __CHANG3_ME__
      POSTGRES_DB: homeservicesdb
```

---

## Verification

### 1. UUID without typeHint should fail

```typescript
// This should FAIL locally now (matching AWS behavior)
await connection.query({
  sql: 'SELECT * FROM users WHERE uuid = $1',
  values: ['627ea5ae-3228-4fbf-9590-4735f77869f7'],
  // Missing typeHint: 'UUID'
});
// ERROR: operator does not exist: uuid = text
```

### 2. UUID with typeHint should pass

```typescript
// This should PASS
await connection.query({
  sql: 'SELECT * FROM users WHERE uuid = $1',
  values: ['627ea5ae-3228-4fbf-9590-4735f77869f7'],
  // typeHint is added automatically by convertToParameters()
});
```

---

## Parity Test

Add integration test to verify local behavior matches AWS:

```typescript
// src/utils/database/getDatabaseConnectionViaRdsDataApi.integration.test.ts

it('should require typeHint for UUID parameters', async () => {
  // This tests that the emulator is strict like real AWS
  const connection = await getConnection(testConfig);

  await expect(
    connection.query({
      sql: 'SELECT * FROM home_service WHERE uuid = $1',
      values: ['627ea5ae-3228-4fbf-9590-4735f77869f7'],
      // Intentionally no typeHint
    })
  ).rejects.toThrow(/operator does not exist: uuid = text/);

  await connection.end();
});
```

---

## Files to Create

| File | Description |
|------|-------------|
| `packages/strict-rds-data-api/package.json` | Package manifest |
| `packages/strict-rds-data-api/tsconfig.json` | TypeScript config |
| `packages/strict-rds-data-api/src/index.ts` | Entry point |
| `packages/strict-rds-data-api/src/server.ts` | Express server |
| `packages/strict-rds-data-api/src/executor.ts` | SQL execution |
| `packages/strict-rds-data-api/src/typeMapping.ts` | Type OID mapping |
| `packages/strict-rds-data-api/src/types.ts` | TypeScript types |
| `packages/strict-rds-data-api/src/resultFormatter.ts` | Response formatting |
| `packages/strict-rds-data-api/Dockerfile` | Container image |

## Files to Modify

| File | Change |
|------|--------|
| `provision/docker/integration-test-db/docker-compose.yml` | Replace `koxudaxi/local-data-api` with custom image |
| `pnpm-workspace.yaml` | Add `packages/strict-rds-data-api` |

---

## Trade-offs

### Pros
- Catches type issues locally that would fail on real AWS
- Simple Node.js implementation - no Kotlin/JVM dependencies
- Uses same `pg` driver patterns already in codebase
- Full control over behavior and error messages

### Cons
- Maintenance burden - must keep in sync with AWS RDS Data API changes
- May not perfectly match all AWS quirks (transactions, batch, etc.)
- Additional build step in CI
- More code to maintain vs. just enabling `typeHint` (which works)

---

## Alternative: Just Use typeHint

The simpler solution is to always provide `typeHint` in `convertToParameters()`:

```typescript
typeHint: getTypeHint(value),
```

This works on both the lenient local emulator and strict AWS. The emulator ignores unnecessary hints, while AWS requires them.

**Recommendation:** Start with enabling `typeHint`, build the strict emulator only if type parity issues keep recurring.
