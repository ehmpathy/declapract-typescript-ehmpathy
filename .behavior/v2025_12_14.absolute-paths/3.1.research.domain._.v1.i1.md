# research: absolute paths in typescript via `@src` alias

## summary

there are two primary approaches for implementing absolute path imports in typescript:

1. **tsconfig `paths` + build-time resolution** (traditional)
2. **node.js subpath imports via `package.json` `imports` field** (modern, recommended)

the modern approach using subpath imports is recommended for new projects as it's natively supported by node.js and fully supported in typescript since v5.4.

---

## approach 1: tsconfig paths + build-time resolution

### configuration

the traditional approach uses `tsconfig.json` with `baseUrl` and `paths`:

> "You need to update your tsconfig.json file to enable aliases by adding a `paths` and `baseUrl` property to the compilerOptions object. Each path is relative to the baseUrl." [1]

> "As of TypeScript 4.1, baseUrl is no longer required to be set when using paths." [2]

example configuration:
```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@src/*": ["src/*"]
    }
  }
}
```

### the core problem: runtime resolution

> "The TypeScript compiler can resolve paths from tsconfig so it will compile OK. But if you then try to execute the compiled files with node (or ts-node), it will only look in the node_modules folders all the way up to the root of the filesystem and thus will not find the modules specified by paths in tsconfig." [3]

> "It is important to note that the compiler will not perform any of these transformations; it just uses these pieces of information to guide the process of resolving a module import to its definition file. This means 'paths' are intended to describe mappings that the build tool or runtime already performs, not to tell the build tool or runtime how to resolve modules." [2]

### solution 1a: runtime resolution with tsconfig-paths

> "If you require the tsconfig-paths/register module it will read the paths from tsconfig.json or jsconfig.json and convert node's module loading calls into physical file paths that node can load." [3]

usage:
```
"dev": "ts-node -r tsconfig-paths/register src/main.ts"
```

drawbacks:
> "Requires a dependency (e.g. tsconfig-paths). Requires injection of a loader via command line or in code. Small(?) performance hit during runtime." [4]

### solution 1b: build-time resolution with tsc-alias

> "When you compile your TypeScript code, the aliases remain in the JavaScript output. Once the code is compiled, it still contains import paths like `@/src/server`, which Node cannot resolve." [5]

> "tsc-alias will post-process the compiled files inside dist/, replacing any alias-based imports with the corresponding relative paths that Node can understand." [5]

usage:
```json
{
  "scripts": {
    "build": "tsc && tsc-alias"
  }
}
```

> "If subpath imports aren't an option yet, it's recommended to use path aliases with build time resolution. This is fairly well supported across tooling today. There's no runtime performance hit, and no risk of running the code in an environment that has no support." [4]

---

## approach 2: node.js subpath imports (recommended)

### what are subpath imports?

> "In addition to the 'exports' field, there is a package 'imports' field to create private mappings that only apply to import specifiers from within the package itself." [6]

> "Entries in the imports field must start with the `#` symbol. This ensures that they are distinguished from package specifiers like `@`." [7]

> "The `#hash` specifier syntax must be used (not `@` or `~`). The `"#/*"` alias is invalid, but as short as `"#@/*"` is valid." [7]

### configuration

in `package.json`:
```json
{
  "imports": {
    "#src/*": "./src/*"
  }
}
```

usage in code:
```ts
import { something } from '#src/utils/helper';
```

### typescript support

> "Subpath imports are supported natively by Node.js (since v12.19.0/v14.6.0) and fully supported in TypeScript since v5.4.0." [4]

> "As of TypeScript 5.4, TypeScript will now automatically use the subpath imports defined within your package.json, meaning we no longer need to redundantly re-define them inside the tsconfig.json." [8]

> "Support for subpath imports in package.json has been in TypeScript since v4.5, so tsc compiles them just fine. But the TypeScript Language Server did not fully catch up until v5.4." [8]

### why subpath imports are recommended

> "Subpath imports are perhaps less well known and less used today compared to TypeScript path aliases, but likely to become even more of a standard in the future. So subpath imports are generally recommended over path aliases going forward, especially considering support in TypeScript v5.4 has fully caught up." [4]

> "Both libraries and apps can consider package.json 'imports' as a standard replacement for convenience paths aliases." [4]

benefits:
- natively supported by node.js (no runtime dependencies)
- no build-time post-processing needed
- single source of truth in `package.json`
- works with both esm and commonjs (with caveats)

### known limitation: commonjs extension resolution

> "A GitHub issue from January 2024 reports that subpath imports with the 'imports' field in CommonJS does not try to resolve with extensions automatically. The runtime will not try to resolve the requested path with registered extensions in CommonJS mode." [9]

---

## comparison: `@src` vs `#src`

| aspect             | tsconfig paths (`@src`)              | subpath imports (`#src`) |
| ------------------ | ------------------------------------ | ------------------------ |
| prefix             | `@` (configurable)                   | `#` (required by spec)   |
| config location    | `tsconfig.json`                      | `package.json`           |
| runtime support    | requires tsconfig-paths or tsc-alias | native node.js support   |
| typescript support | full                                 | full (since v5.4)        |
| build step needed  | yes (tsc-alias) or runtime dep       | no                       |

---

## recommendation for the wish

given the wish requests `@src` -> `@gitroot/src`:

1. **if `#` prefix is acceptable**: use node.js subpath imports
   - add to `package.json`: `"imports": { "#src/*": "./src/*" }`
   - no additional dependencies or build steps needed
   - requires typescript 5.4+

2. **if `@` prefix is required**: use tsconfig paths + tsc-alias
   - add to `tsconfig.json`: `"paths": { "@src/*": ["src/*"] }`
   - add tsc-alias to build step: `"build": "tsc && tsc-alias"`
   - requires additional dev dependency

---

## citations

1. [Simpler Typescript paths with path aliases – Christian Lüdemann](https://christianlydemann.com/simpler-typescript-paths-with-path-aliases/)

2. [TypeScript: TSConfig Reference – paths](https://www.typescriptlang.org/tsconfig/paths.html)

3. [tsconfig-paths – npm](https://www.npmjs.com/package/tsconfig-paths)

4. [Using subpath imports & path aliases – Lars Kappert](https://webpro.nl/articles/using-subpath-imports-and-path-aliases)

5. [tsc-alias – npm](https://www.npmjs.com/package/tsc-alias)

6. [Modules: Packages | Node.js Documentation](https://nodejs.org/api/packages.html)

7. [Setting up Subpath Import Aliases in a TypeScript Project – Vitaliy Potapov](https://medium.com/@vitaliypotapov/setting-up-subpath-import-aliases-in-a-typescript-project-3ee027b75f1d)

8. [Setting up Subpath Import Aliases in a TypeScript Project – DEV Community](https://dev.to/vitalets/setting-up-subpath-imports-in-a-typescript-project-4i0a)

9. [Subpath imports with "imports" field in CommonJS does not try to resolve with extensions · Issue #51492 · nodejs/node](https://github.com/nodejs/node/issues/51492)
