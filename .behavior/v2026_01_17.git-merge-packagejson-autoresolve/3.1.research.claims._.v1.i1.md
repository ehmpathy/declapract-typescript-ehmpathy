# research: claims

## legend

- **[FACT]** = indisputable, immutable truth
- **[SUMP]** = assumption (explicit or implicit)
- **[KHUE]** = open question to consider
- **[OPIN]** = subjective declaration to consider

---

## 1. semver precedence rules

### [FACT] stable versions are higher than pre-releases with same major.minor.patch

> "When major, minor, and patch are equal, a pre-release version has lower precedence than a normal version: Example: 1.0.0-alpha < 1.0.0." [1]

> "1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0." [1]

**implication:** when `1.0.0-beta` conflicts with `1.0.0`, always pick `1.0.0`

### [FACT] pre-release versions indicate instability

> "A pre-release version indicates that the version is unstable and might not satisfy the intended compatibility requirements as denoted by its associated normal version." [1]

**citation:** [1] semver.org — Semantic Versioning 2.0.0

---

## 2. git merge conflict behavior

### [FACT] git cannot auto-resolve delete vs modify conflicts

> "Conflicts generally arise when two people have changed the same lines in a file, or if one developer deleted a file while another developer was modifying it. In these cases, Git cannot automatically determine what is correct." [2]

> "Modify/delete conflicts occur when, on one branch in the merge operation, a file has been modified. At the same time, on the other branch, the same file has been deleted, making it impossible for the system to perform an automatic merge without human intervention." [3]

**implication:** our wish to honor removal intent requires custom logic — git does not provide this

### [FACT] git merge driver must write result to %A and exit 0 for success

> "The driver must overwrite the file named `%A` with the merge result." [4]

> "Return 0 for a clean merge." [4]

**citation:**
- [2] atlassian.com/git/tutorials/merge-conflicts
- [3] 4sysops.com — Resolve modify/delete merge conflicts in Git
- [4] git-scm.com/docs/gitattributes

---

## 3. risks of always use higher versions

### [OPIN] updated dependencies introduce risk and instability

> "Updated dependencies introduce a lot of risk and instability into your project. Fundamentally, updating dependencies is a dangerous operation." [5]

> "Most people would never deploy changes to production without code review, but many feel comfortable bumping a package.json number without looking at the diff of what changed in the dependency." [5]

### [FACT] higher versions can break api compatibility

> "While selecting the higher version seems logical, it can cause problems if Library A uses an API that was removed or changed in the newer version. At runtime, when Library A tries to call that now-missing API, your application will throw an error." [6]

> "API incompatibility of direct dependencies results in compilation errors. Diamond dependency incompatibility usually results in runtime failures such as NoClassDefFoundError, NoSuchMethodError, or other LinkageError." [6]

### [OPIN] semver reliability depends on maintainer discipline

> "Relying on semver only saves you if you actually read the CHANGELOG, or if the package author correctly identifies a breaking change." [5]

**citation:**
- [5] kevin.burke.dev — Maybe Automatically Updating Dependencies Isn't a Great Idea
- [6] baeldung.com — How to Resolve a Version Collision of Artifacts in Maven

---

## 4. default behaviors in build tools

### [FACT] gradle and nuget default to higher version

> "By default, Gradle will select the highest version out of all requested versions." [6]

> "NuGet's dependency resolution logic will select the higher version by default." [6]

### [SUMP] higher version is usually the desired outcome

**implication:** build tools assume that newer is better, but this assumption can fail

**citation:** [6] baeldung.com; docs.gradle.org

---

## 5. npm conflict resolution capabilities

### [FACT] npm 5.7.0+ can auto-resolve package-lock.json conflicts

> "As of npm@5.7.0, these conflicts can be resolved by manually fixing any package.json conflicts, and then running `npm install [--package-lock-only]` again. npm will automatically resolve any conflicts for you and write a merged package lock that includes all the dependencies from both branches in a reasonable tree." [7]

### [FACT] npm cannot auto-resolve package.json conflicts

> "If package.json itself conflicts, you will have to resolve that by hand and run npm install manually, even with the merge driver." [8]

**implication:** our tool fills a gap — npm handles lockfile but not package.json itself

**citation:**
- [7] docs.npmjs.com/about-semantic-versioning
- [8] github.com/npm/npm-merge-driver/issues/24

---

## 6. dependency section migrations

### [FACT] yarn 1.x had bugs with dependency section moves

> "If you put a package in 'devDependencies', generate a yarn.lock, then move the package from 'devDependencies' to 'dependencies' and rerun yarn install, the lock file does not change. Subsequently the package will not be installed if `yarn install --production` is executed." [9]

> "This issue has been fixed in Yarn 2+." [9]

**implication:** dependency section moves are a real scenario that tools must handle

**citation:** [9] github.com/yarnpkg/yarn/issues/5091

---

## 7. non-semver version specifiers

### [FACT] package.json supports non-comparable version specifiers

non-semver specifiers include:
- `"latest"` or `"*"` — resolved at install time
- `"file:../local-package"` — local path reference
- `"workspace:^1.0.0"` — monorepo workspace protocol

> "The `latest` tag may not always be the highest version number - it's whatever the maintainer tagged as latest." [10]

**implication:** version comparison must handle non-semver gracefully (preserve as-is)

**citation:** [10] gist.github.com — npm version cheatsheet

---

## 8. json merge driver approaches

### [FACT] semantic json merges can auto-resolve different-key changes

> "The driver automatically resolves conflicts when multiple branches modify different keys in the same file. If a conflict cannot be resolved automatically (e.g., same key modified on both sides), Git falls back to standard conflict markers." [11]

### [SUMP] key-level merge is sufficient for json

**implication:** for package.json, we need deeper logic (semver comparison, removal intent)

**citation:** [11] github.com/onetimesecret/onetimesecret/issues/2015

---

## 9. removal intent vs update conflict

### [KHUE] what should win: removal or update?

git does not define precedence. our wish specifies:
> "in cases where a dependency was explicitly removed from a branch but kept in another, always union the intent and remove it" [wish]

this is a **policy decision**, not a fact. alternatives exist:
- keep the update (removal might be accidental)
- keep the removal (update might be reverted intentionally)
- require manual review (ambiguous intent)

### [OPIN] explicit deletion should be honored

the wish assumes removal is intentional and should take precedence. this is a reasonable default for cleanup scenarios but could lose valid updates in edge cases.

---

## 10. lockfile regeneration

### [SUMP] lockfile should be regenerated after package.json merge

> "Then run `npm install` to regenerate package-lock.json to include your local changes." [12]

> "The best way to handle package-lock.json conflicts is to avoid them entirely." [12]

**implication:** our tool should NOT auto-resolve lockfiles — let npm regenerate them

**citation:** [12] martin.beryllium.net — Automatically resolve NPM package-lock conflicts

---

## 11. pinned versions vs ranges

### [OPIN] exact versions are safer than ranges

> "Generally, you should lock down the exact versions of every dependency and sub-dependency that you use." [5]

> "Using latest without pinning isn't good practice as it can easily break your build when a new dependency version is released without testing." [5]

### [KHUE] how to compare ranges like `^1.2.3` vs `^1.3.0`?

the wish says "pick the latest version" but ranges don't have a single version. options:
- compare the minimum satisfiable version
- compare the maximum satisfiable version
- preserve the range with higher lower-bound

---

## 12. automation vs human review

### [OPIN] automatic updates require mature test pipelines

> "Automatic dependency updates require mature delivery pipelines. It's no good automatically updating dependencies if building your system is a bottleneck, or if the quality of automated tests would not catch subtle bugs from incompatible transitive dependencies that sail through to production." [13]

### [OPIN] non-dependency fields should require human review

> "If package.json itself conflicts, you will have to resolve that by hand." [8]

fields like `name`, `version`, `scripts`, `engines` have semantic implications beyond simple text merge.

**citation:** [13] beny23.github.io — The Case Against Automatic Dependency Updates

---

## 13. security considerations

### [FACT] outdated dependencies have higher vulnerability risk

> "In the event of an urgent security patch (zero-day vulnerability), developers that use the most recent version of the vulnerable dependency face a drastically lower risk of breaking their build." [14]

> "Over 90 percent of new vulnerabilities in NPM packages have security patches before public disclosure. These vulnerabilities can be prevented by maintaining up-to-date dependencies." [14]

**implication:** higher versions are generally safer from security perspective

**citation:** [14] endorlabs.com — The Uncomfortable Truth of Vulnerable and Outdated Software Components

---

## 14. incremental vs batch updates

### [OPIN] incremental updates are easier to debug

> "Dependency updates compose well: It's easier to update 5 packages individually than all at once - you'll know what change caused a build break or performance regression. It's also easier to assess the risk of a single package update than running npm update and hoping for the best." [5]

**implication:** our merge logic is incremental by nature (handles one conflict at a time)

---

## open questions for our implementation

### [RESOLVED] should we support dry-run mode?

**decision:** NO — the tool always writes the result. users can use git to inspect changes after.

### [RESOLVED] how to handle version ranges like `^1.2.3` vs `~1.3.0`?

**decision:** strip qualifiers for comparison, keep the winner as-is.
- compare `1.2.3` vs `1.3.0` (without ^/~)
- `1.3.0` wins → keep `~1.3.0` in result

### [KHUE] how to handle unresolvable conflicts?

when both branches modify the same dependency to incompatible versions (e.g., `^1.0.0` vs `^2.0.0`), should we:
- pick higher anyway? ← **likely yes, per the version comparison logic**
- fall back to conflict markers?
- emit a notice?

### [KHUE] should removal trump update in all cases?

the wish says yes, but what if:
- removal was accidental (user deleted wrong line)
- update contains critical security fix
- removal happened on stale branch

**current stance:** yes, removal wins (per wish)

### [RESOLVED] how to handle scripts and other non-dependency fields?

**decision:** leave them with conflict markers. only dependency sections are resolved.
- dependencies, devDependencies, peerDependencies, optionalDependencies = resolved
- all other fields = left for human review

---

## sources

1. [semver.org](https://semver.org/) — Semantic Versioning 2.0.0
2. [atlassian.com/git/tutorials/merge-conflicts](https://www.atlassian.com/git/tutorials/using-branches/merge-conflicts)
3. [4sysops.com](https://4sysops.com/archives/resolve-modifydelete-merge-conflicts-in-git/) — Resolve modify/delete merge conflicts
4. [git-scm.com/docs/gitattributes](https://git-scm.com/docs/gitattributes) — gitattributes documentation
5. [kevin.burke.dev](https://kevin.burke.dev/kevin/dont-update-dependencies/) — Maybe Automatically Updating Dependencies Isn't a Great Idea
6. [baeldung.com](https://www.baeldung.com/maven-version-collision) — How to Resolve a Version Collision
7. [docs.npmjs.com](https://docs.npmjs.com/about-semantic-versioning/) — About semantic versioning
8. [github.com/npm/npm-merge-driver/issues/24](https://github.com/npm/npm-merge-driver/issues/24) — Handle simple package.json conflicts
9. [github.com/yarnpkg/yarn/issues/5091](https://github.com/yarnpkg/yarn/issues/5091) — Moving package from devDependencies to dependencies
10. [gist.github.com](https://gist.github.com/jonlabelle/706b28d50ba75bf81d40782aa3c84b3e) — npm version cheatsheet
11. [github.com/onetimesecret/onetimesecret/issues/2015](https://github.com/onetimesecret/onetimesecret/issues/2015) — Git JSON Merge Driver
12. [martin.beryllium.net](https://martin.beryllium.net/2019/08/02/automatically-resolve-npm-package-lock-conflicts-using-git/) — Automatically resolve NPM package-lock conflicts
13. [beny23.github.io](https://beny23.github.io/posts/automatic_dependency_updates/) — The Case Against Automatic Dependency Updates
14. [endorlabs.com](https://www.endorlabs.com/learn/the-uncomfortable-truth-of-vulnerable-and-outdated-software-components) — Vulnerable and Outdated Software Components
