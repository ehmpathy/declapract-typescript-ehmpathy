# Blueprint: please-release-action

## Summary

Replace `google-github-actions/release-please-action@v3.7.6` with a custom, opinionated release action that is:
- Faster (target: <5s vs current 30s)
- Simpler (no wrapping/post-processing needed)
- Stable (no external dependency breaking changes)

## Implementation Strategy

### approach: collocated composite action (bash-only)

Create a composite action at `.github/actions/please-release/action.yml` that uses pure bash.

**Why this approach:**
- **Collocated**: Lives in the repo, copied by declapract to all target repos
- **No external dependencies**: No npm package to publish/maintain
- **No node runtime**: Pure bash with `using: "composite"` and `shell: bash`
- **Fast**: No action setup overhead, no node setup
- **Encapsulated**: Clean inputs/outputs interface
- **Testable**: Can test the action in isolation
- **Portable**: Declapract copies it along with the workflow

**Structure:**
```
.github/
â”œâ”€â”€ actions/
â”‚   â””â”€â”€ please-release/
â”‚       â””â”€â”€ action.yml    # using: "composite", all bash steps
â””â”€â”€ workflows/
    â””â”€â”€ release.yml       # uses: ./.github/actions/please-release
```

---

## Architecture

### workflow (release.yml)

```yaml
name: release

on:
  push:
    branches: [main]

jobs:
  please-release:
    runs-on: ubuntu-24.04
    steps:
      - name: get github token
        id: github-token
        uses: actions/create-github-app-token@v2
        with:
          owner: ehmpathy
          repositories: ${{ github.event.repository.name }}
          app-id: ${{ vars.RHELEASE_APP_ID }}
          private-key: ${{ secrets.RHELEASE_APP_PRIVATE_KEY }}

      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ steps.github-token.outputs.token }} # enables git push with app token

      - name: please release
        uses: ./.github/actions/please-release
        with:
          github-token: ${{ steps.github-token.outputs.token }}
          commit-message: ${{ github.event.head_commit.message }}
          commit-sha: ${{ github.sha }}
          repository: ${{ github.repository }}
```

### composite action (action.yml)

```yaml
name: please-release
description: upsert release pr or cutta release tag

inputs:
  github-token: # masked by github, since it's marked as a secret
    description: token for gh cli calls
    required: true
  commit-message:
    description: the head commit message
    required: true
  commit-sha:
    description: the head commit sha
    required: true
  repository:
    description: the repository (owner/repo)
    required: true

outputs:
  action:
    description: what action was taken (noop, created, updated, released)
  version:
    description: the computed or released version
  pr-number:
    description: the release pr number

runs:
  using: "composite"
  steps:
    - name: cutta tag, if release commit
      id: cutta
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
      run: # ... outputs: did-cutta (true/false)

    - name: crunch future semver, if other commit
      id: semver
      if: ${{ steps.cutta.outputs.did-cutta == 'false' }}
      shell: bash
      run: # ...

    - name: crunch future changelog, if other commit
      id: changelog
      if: ${{ steps.cutta.outputs.did-cutta == 'false' }}
      shell: bash
      run: # ...

    - name: upsert release pr, if other commit
      id: upsert
      if: ${{ steps.cutta.outputs.did-cutta == 'false' }}
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
      run: # ...
```

### module decomposition

```
.github/actions/please-release/action.yml
â”œâ”€â”€ step 1: cutta tag, if release commit
â”‚     â”œâ”€â”€ check if message starts with "chore(release):"
â”‚     â”œâ”€â”€ if yes: extract version, create tag, create release, comment on prs
â”‚     â””â”€â”€ output: did-cutta (true/false)
â”‚
â”œâ”€â”€ step 2: crunch future semver, if other commit
â”‚     â”œâ”€â”€ get latest tag
â”‚     â”œâ”€â”€ get commits since tag
â”‚     â””â”€â”€ compute next version based on commit types
â”‚
â”œâ”€â”€ step 3: crunch future changelog, if other commit
â”‚     â”œâ”€â”€ group commits by type (breaks, feats, fixes)
â”‚     â””â”€â”€ format with links to prs and commits
â”‚
â””â”€â”€ step 4: upsert release pr, if other commit
      â”œâ”€â”€ query: open release pr
      â”œâ”€â”€ check: uptilCommit label matches head
      â””â”€â”€ action: create or update pr
```

---

## Implementation Details

### step 1: cutta tag, if release commit (scope.cut-tag)

```bash
COMMIT_MSG="${{ inputs.commit-message }}"

# check if this is a release commit
if [[ "$COMMIT_MSG" != chore\(release\):* ]]; then
  echo "did-cutta=false" >> $GITHUB_OUTPUT
  exit 0
fi

# extract version from commit message
VERSION=$(echo "$COMMIT_MSG" | sed -n 's/^chore(release): \(v[0-9.]*\).*/\1/p')

# failfast if version not found
if [ -z "$VERSION" ]; then
  echo "::error::could not extract version from commit message: $COMMIT_MSG"
  exit 1
fi

# find the release pr that was merged
PR_NUMBER=$(gh pr list --state merged --search "chore(release): $VERSION" --json number --jq '.[0].number')

# failfast if release pr not found
if [ -z "$PR_NUMBER" ]; then
  echo "::error::could not find merged release pr for version: $VERSION"
  exit 1
fi

# failfast if release pr was not labeled with expected version
PR_LABELS=$(gh pr view "$PR_NUMBER" --json labels --jq '.labels[].name')
if ! echo "$PR_LABELS" | grep -q "^release=$VERSION$"; then
  echo "::error::release pr #$PR_NUMBER was not labeled with release=$VERSION"
  exit 1
fi

# create and push tag
git tag "$VERSION"
git push origin "$VERSION"

# create github release
RELEASE_URL=$(gh release create "$VERSION" \
  --title "$VERSION" \
  --generate-notes \
  --latest)

# comment on the release pr
gh pr comment "$PR_NUMBER" --body "ðŸŒŠ released at ${RELEASE_URL}"

# extract pr links from the release pr body and comment on each
PR_BODY=$(gh pr view "$PR_NUMBER" --json body --jq '.body')
REFERENCED_PRS=$(echo "$PR_BODY" | grep -oE '\[#[0-9]+\]\([^)]+/issues/([0-9]+)\)' | grep -oE '[0-9]+' || true)

for REF_PR in $REFERENCED_PRS; do
  gh pr comment "$REF_PR" --body "ðŸŒŠ released at ${RELEASE_URL}" 2>/dev/null || true
done

echo "did-cutta=true" >> $GITHUB_OUTPUT
```

### step 2: crunch future semver, if other commit (scope.semver)

```bash
# get latest tag (or default to v0.0.0 for first release)
LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")

# handle first release
if [ "$LATEST_TAG" = "v0.0.0" ]; then
  echo "next-version=v0.1.0" >> $GITHUB_OUTPUT
  exit 0
fi

# get commits since tag
COMMITS=$(git log ${LATEST_TAG}..HEAD --pretty=format:"%s")

# determine bump type
BUMP="patch"  # default

if echo "$COMMITS" | grep -qE "^break(\(.+\))?:"; then
  BUMP="major"
elif echo "$COMMITS" | grep -qE "^feat(\(.+\))?:"; then
  BUMP="minor"
fi

# compute next version
CURRENT="${LATEST_TAG#v}"
IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT"

case $BUMP in
  major) NEXT_VERSION="v$((MAJOR + 1)).0.0" ;;
  minor) NEXT_VERSION="v${MAJOR}.$((MINOR + 1)).0" ;;
  patch) NEXT_VERSION="v${MAJOR}.${MINOR}.$((PATCH + 1))" ;;
esac

echo "next-version=$NEXT_VERSION" >> $GITHUB_OUTPUT
```

### step 3: crunch future changelog, if other commit (scope.changelog)

```bash
REPO_URL="https://github.com/${{ github.repository }}"
PREV_TAG="$LATEST_TAG"
NEXT_TAG="$NEXT_VERSION"
TODAY=$(date +%Y-%m-%d)

# group commits by type (hash, date, subject)
FEATS=$(git log ${PREV_TAG}..HEAD --pretty=format:"%H %cs %s" | grep -E "^[a-f0-9]+ [0-9-]+ feat(\(.+\))?:" || true)
FIXES=$(git log ${PREV_TAG}..HEAD --pretty=format:"%H %cs %s" | grep -E "^[a-f0-9]+ [0-9-]+ fix(\(.+\))?:" || true)
BREAKS=$(git log ${PREV_TAG}..HEAD --pretty=format:"%H %cs %s" | grep -E "^[a-f0-9]+ [0-9-]+ break(\(.+\))?:" || true)

# format changelog
CHANGELOG="## [${NEXT_TAG#v}](${REPO_URL}/compare/${PREV_TAG}...${NEXT_TAG}) (${TODAY})"

format_commits() {
  local commits="$1"
  while IFS= read -r line; do
    [ -z "$line" ] && continue
    HASH="${line%% *}"
    REST="${line#* }"
    DATE="${REST%% *}"
    MSG="${REST#* }"
    SHORT_HASH="${HASH:0:7}"

    # extract pr number from message if present
    PR_NUM=$(echo "$MSG" | grep -oE '\(#[0-9]+\)' | head -1 | tr -d '(#)')

    # remove pr tag from message for cleaner display
    MSG_CLEAN=$(echo "$MSG" | sed -E 's/ *\(#[0-9]+\) *//')

    echo "â—‹ ${MSG_CLEAN}"
    if [ -n "$PR_NUM" ]; then
      echo "   â”œâ”€â”€ ${DATE}"
      echo "   â”œâ”€â”€ [#${PR_NUM}](${REPO_URL}/pull/${PR_NUM})"
      echo "   â””â”€â”€ [${SHORT_HASH}](${REPO_URL}/commit/${HASH})"
    else
      echo "   â”œâ”€â”€ ${DATE}"
      echo "   â””â”€â”€ [${SHORT_HASH}](${REPO_URL}/commit/${HASH})"
    fi
  done <<< "$commits"
}

if [ -n "$BREAKS" ]; then
  CHANGELOG+="\n\n### breaks\n\n$(format_commits "$BREAKS")"
fi
if [ -n "$FEATS" ]; then
  CHANGELOG+="\n\n### feats\n\n$(format_commits "$FEATS")"
fi
if [ -n "$FIXES" ]; then
  CHANGELOG+="\n\n### fixes\n\n$(format_commits "$FIXES")"
fi
```

### step 4: upsert release pr, if other commit (scope.upsert-pr)

```bash
RELEASE_LABEL="purpose=release"

# failfast if package.json doesnt exist
if [ ! -f package.json ]; then
  echo "::error::package.json not found"
  exit 1
fi

# find existing release pr
EXISTING_PR=$(gh pr list --state open --label "$RELEASE_LABEL" --json number,headRefName --jq '.[0]')

PR_BODY="ðŸ¢ noice! ready to let these changes ride?\n---\n\n${CHANGELOG}"

if [ -n "$EXISTING_PR" ]; then
  PR_NUMBER=$(echo "$EXISTING_PR" | jq -r '.number')
  BRANCH=$(echo "$EXISTING_PR" | jq -r '.headRefName')

  # update package.json on release branch
  git fetch origin "$BRANCH"
  git checkout "$BRANCH"
  npm version "${NEXT_VERSION#v}" --no-git-tag-version
  git add package.json
  git commit -m "chore(release): ${NEXT_VERSION} ðŸŽ‰"
  git push origin "$BRANCH"

  # update pr metadata
  gh pr edit "$PR_NUMBER" \
    --title "chore(release): ${NEXT_VERSION} ðŸŽ‰" \
    --body "$PR_BODY"

  # update labels
  gh pr edit "$PR_NUMBER" --add-label "release=${NEXT_VERSION}"
else
  # create release branch and pr
  BRANCH="release/${NEXT_VERSION}"
  git checkout -b "$BRANCH"

  # update package.json version
  npm version "${NEXT_VERSION#v}" --no-git-tag-version
  git add package.json
  git commit -m "chore(release): ${NEXT_VERSION} ðŸŽ‰"

  git push origin "$BRANCH"

  gh pr create \
    --title "chore(release): ${NEXT_VERSION} ðŸŽ‰" \
    --body "$PR_BODY" \
    --base main \
    --head "$BRANCH" \
    --label "$RELEASE_LABEL" \
    --label "release=${NEXT_VERSION}"
fi
```

---

## Files to Create/Modify

### 1. Create Composite Action

**File:** `src/practices/cicd-common/best-practice/.github/actions/please-release/action.yml`

The composite action containing all the bash logic for release management.

### 2. Update Best Practice Workflow

**File:** `src/practices/cicd-common/best-practice/.github/workflows/release.yml`

Simplify to just checkout + token + call the composite action. This will automatically flag any repos with the old release-please-action pattern since it's the same file path.

### 3. Update Commitlint Config (scope.commitlint)

**File:** `src/practices/commits/best-practice/commitlint.config.cjs`

Add `break` to allowed types, forbid `BREAKING CHANGE` footer and `!` prefix.

```javascript
module.exports = {
  extends: ['@commitlint/config-conventional'],
  rules: {
    'type-enum': [
      2,
      'always',
      ['feat', 'fix', 'break', 'docs', 'style', 'refactor', 'perf', 'test', 'chore', 'revert', 'ci', 'build'],
    ],
    // Forbid ! prefix (use break: instead)
    'subject-exclamation-mark': [2, 'never'],
  },
};
```

### 4. Add Bad Practice for changelog.md

**File:** `src/practices/cicd-common/bad-practices/has-changelog-file/changelog.md.declapract.ts`

The old release-please-action creates and maintains a `changelog.md` file. Our new action embeds the changelog directly in the release PR description, so `changelog.md` is no longer needed. This bad practice flags repos that have a `changelog.md` and fixes by deleting it.

```typescript
import { FileCheckType, type FileFixFunction } from 'declapract';

export const check = FileCheckType.EXISTS;

export const fix: FileFixFunction = () => {
  return { contents: null }; // delete the file
};
```

---

## Migration Path

### phase 1: implement
1. Create composite action at `.github/actions/please-release/action.yml`
2. Update `release.yml` to use the composite action
3. Add bad practice for `changelog.md`
4. Update commitlint config to support `break:` type
5. Test in this repo with real releases

### phase 2: validate
1. Measure speed improvement (target: <5s)
2. Verify all criteria from `2.criteria.md` pass
3. Test edge cases (first release, no commits, etc.)

### phase 3: roll out
1. Run `declapract apply` against ehmpathy repos
2. Composite action + workflow get copied together
3. Old release-please-action pattern replaced automatically
4. Legacy `changelog.md` files flagged for deletion

---

## Speed Optimization

### current (release-please-action): ~30s
- Action setup: ~5s
- Node setup: ~10s
- release-please execution: ~15s

### target (composite action): <5s
- No node runtime (pure bash)
- Direct gh CLI calls
- Early exit on noop

### key optimizations
1. **Early exit on noop**: Check uptilCommit label before any computation
2. **Single checkout**: `fetch-depth: 0` gives us all tags and commits
3. **Minimal API calls**: Only call GitHub API when needed
4. **Pure bash**: No node runtime, no npm install

---

## Risk Mitigation

### risk: changelog format differences
**Mitigation:** Match existing release-please format exactly, update only aesthetic elements (emoji, section names)

### risk: label conflicts
**Mitigation:** Use unique label prefix (`purpose=release`, `release=`)

### risk: race conditions
**Mitigation:** Use `gh pr edit` atomic operations, check state before update

### risk: first release edge case
**Mitigation:** Explicit check for no tags, default to v0.1.0

---

## Success Criteria

1. Release workflow completes in <5s (vs current 30s)
2. PR title/body format matches specification exactly
3. All scope.* criteria from 2.criteria.md pass
4. No manual post-processing steps needed
5. Clean migration path for existing repos
