# blueprint: use.apikeys.json integration with cicd workflows

## overview

implement declapract best-practices that:
1. ensure `use.apikeys.json` exists with proper structure (owned by `cicd-common`)
2. ensure `.test.yml` declares secrets for each apikey
3. ensure `test.yml`, `publish.yml`, `deploy.yml` pass secrets to `.test.yml`

## ownership model

**key decision:** move `use.apikeys.json` and `use.apikeys.sh` from `tests` practice to `cicd-common` practice.

**rationale:**
- `use.apikeys.json` declares which secrets CI/CD workflows need
- the file is fundamentally about CI/CD configuration, not just local testing
- single ownership avoids cross-practice conflicts and permanent diffs
- all projects using any `cicd-*` practice automatically get apikey infrastructure

---

## domain model

### UseApikeysConfig
```ts
interface UseApikeysConfig {
  apikeys: {
    required: string[];  // e.g., ['ANTHROPIC_API_KEY', 'OPENAI_API_KEY']
  };
}
```

### workflow secrets structure (yaml)
```yaml
# .test.yml - declares inputs
on:
  workflow_call:
    secrets:
      ANTHROPIC_API_KEY:
        description: "api key for anthropic claude, used in integration tests"
        required: false
      # ... for each key in use.apikeys.json

# test.yml / publish.yml / deploy.yml - passes secrets
jobs:
  test:
    uses: ./.github/workflows/.test.yml
    secrets:
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      # ... for each key in use.apikeys.json
```

---

## declapract contract

### FileFixFunction signature
```ts
type FileFixFunction = (
  contents: string | null,      // user's current file (null if doesn't exist)
  context: FileCheckContext,    // context with project info
) => { contents?: string | null; relativeFilePath?: string } | Promise<...>;
```

### FileCheckContext properties
```ts
interface FileCheckContext {
  relativeFilePath: string;           // path of file being checked
  declaredFileContents: string | null; // template from best-practice folder
  projectVariables: Record<...>;       // project variables
  projectPractices: string[];          // enabled practices
  required: boolean;                   // if file is required
  getProjectRootDirectory: () => string; // project root path
}
```

### check/fix contract
- **check function**: throw = file passes (not a match for bad practice), return = file fails (is a match)
- **fix function**: receives user's current file, returns the fixed version
- **idempotency**: fix should produce same output when run multiple times
- **check strategy**: build the exact blocks fix would write, verify they're already present

---

## implementation plan

### phase 0: relocate apikey files from tests to cicd-common

#### 0.1 move files

**from:**
```
src/practices/tests/best-practice/.agent/repo=.this/role=any/skills/
├── use.apikeys.json
├── use.apikeys.json.declapract.ts
├── use.apikeys.sh
└── use.apikeys.sh.declapract.ts
```

**to:**
```
src/practices/cicd-common/best-practice/.agent/repo=.this/role=any/skills/
├── use.apikeys.json
├── use.apikeys.json.declapract.ts
├── use.apikeys.sh
└── use.apikeys.sh.declapract.ts
```

#### 0.2 create bad-practice to remove old location

create `src/practices/tests/bad-practices/old-apikeys-location/` to detect and remove the old files from `tests` practice location, moving them to the new `cicd-common` location.

```
src/practices/tests/bad-practices/old-apikeys-location/
├── .agent/repo=.this/role=any/skills/use.apikeys.json.declapract.ts
├── .agent/repo=.this/role=any/skills/use.apikeys.json.declapract.test.ts
├── .agent/repo=.this/role=any/skills/use.apikeys.sh.declapract.ts
└── .agent/repo=.this/role=any/skills/use.apikeys.sh.declapract.test.ts
```

each declapract file:
```ts
import { FileCheckType, type FileFixFunction } from 'declapract';

export const check = FileCheckType.EXISTS;

export const fix: FileFixFunction = () => {
  return { contents: null }; // delete the file from old location
};
```

**tests:**
- unit test: fix returns null (deletes file)

---

### phase 1: domain utilities

#### 1.1 create `src/utils/readUseApikeysConfig.ts`
```ts
/**
 * .what = reads and parses use.apikeys.json from target project
 * .why = centralizes apikey config access for all workflow practices
 */
export const readUseApikeysConfig = async (
  input: { projectRootDirectory: string },
): Promise<UseApikeysConfig | null> => {
  // read from .agent/repo=.this/role=any/skills/use.apikeys.json
  // return parsed config or null if not found
};
```

**tests:**
- unit test: returns parsed config when file exists
- unit test: returns null when file does not exist
- unit test: handles malformed json gracefully

---

### phase 2: best-practice for use.apikeys.json existence

#### 2.1 create `src/practices/cicd-common/best-practice/.agent/repo=.this/role=any/skills/use.apikeys.json.declapract.ts`

```ts
import { FileCheckType, type FileFixFunction } from 'declapract';

export const check = FileCheckType.EXISTS;

export const fix: FileFixFunction = (contents) => {
  // if file doesn't exist, create default structure
  if (!contents) {
    return {
      contents: JSON.stringify(
        {
          apikeys: {
            required: [],
          },
        },
        null,
        2,
      ) + '\n',
    };
  }
  return { contents };
};
```

**tests:**
- unit test: creates default structure when file doesn't exist
- unit test: preserves content when file already exists

#### 2.2 create `src/practices/cicd-common/best-practice/.agent/repo=.this/role=any/skills/use.apikeys.sh.declapract.ts`

```ts
import { FileCheckType } from 'declapract';

// check that the file contains the core structure
export const check = FileCheckType.CONTAINS;
```

the template `use.apikeys.sh` file remains the same (already exists in tests, will be moved).

---

### phase 3: best-practice for .test.yml secrets declaration

#### 3.1 create `src/practices/cicd-common/best-practice/.github/workflows/.test.yml.declapract.ts`

**approach:** full overwrite with expected content. build `expected` = template + apikey modifications, then:
- `check`: compare `contents === expected`
- `fix`: return `{ contents: expected }`

```ts
import type { FileCheckFunction, FileFixFunction } from 'declapract';
import { readUseApikeysConfig } from '../../../../../utils/readUseApikeysConfig';

/**
 * .what = builds the expected .test.yml content with apikey secrets injected
 * .why = single source of truth for both check and fix
 */
const buildExpectedContent = (
  input: { template: string; apikeys: string[] },
): string => {
  let result = input.template;

  // if no apikeys, return template as-is
  if (!input.apikeys.length) {
    return result;
  }

  // build secrets declaration block for workflow_call
  const secretsDeclaration = input.apikeys
    .map((key) => `      ${key}:\n        description: "api key for ${key}"\n        required: false`)
    .join('\n');

  // build env block for test-integration job
  const envBlock = input.apikeys
    .map((key) => `      ${key}: \${{ secrets.${key} }}`)
    .join('\n');

  // insert secrets declaration after workflow_call inputs
  if (result.includes('inputs:')) {
    result = result.replace(
      /(on:\n  workflow_call:\n    inputs:[\s\S]*?)(\n\njobs:)/,
      `$1\n    secrets:\n${secretsDeclaration}$2`,
    );
  } else {
    result = result.replace(
      /on:\n  workflow_call:/,
      `on:\n  workflow_call:\n    secrets:\n${secretsDeclaration}`,
    );
  }

  // insert env block to test-integration job
  if (result.includes('test-integration:')) {
    result = result.replace(
      /(test-integration:\n    runs-on: [^\n]+\n    needs: \[[^\]]+\])/,
      `$1\n    env:\n${envBlock}`,
    );
  }

  return result;
};

/**
 * .what = ensures .test.yml matches expected content with apikey secrets
 * .why = enables integration tests to access required api keys via github secrets
 */
export const check: FileCheckFunction = async (contents, context) => {
  const apikeysConfig = await readUseApikeysConfig({
    projectRootDirectory: context.getProjectRootDirectory(),
  });

  // build expected content from template + apikeys
  const expected = buildExpectedContent({
    template: context.declaredFileContents ?? '',
    apikeys: apikeysConfig?.apikeys?.required ?? [],
  });

  // if contents match expected, file passes (throw)
  if (contents === expected) {
    throw new Error('file matches expected content');
  }
  // return = file differs from expected (bad practice detected)
};

export const fix: FileFixFunction = async (contents, context) => {
  const apikeysConfig = await readUseApikeysConfig({
    projectRootDirectory: context.getProjectRootDirectory(),
  });

  // build expected content from template + apikeys
  const expected = buildExpectedContent({
    template: context.declaredFileContents ?? '',
    apikeys: apikeysConfig?.apikeys?.required ?? [],
  });

  return { contents: expected };
};
```

**tests:**
- unit test: check throws when no apikeys required
- unit test: check throws when all secrets declared
- unit test: check returns when secrets missing
- unit test: fix adds missing secret declarations
- unit test: fix preserves existing secrets
- unit test: fix preserves yaml comments
- integration test: works with actual use.apikeys.json file

---

### phase 4: best-practice for workflow secrets forwarding

#### 4.1 create `src/practices/cicd-common/best-practice/.github/workflows/test.yml.declapract.ts`

**approach:** full overwrite with expected content. build `expected` = template + apikey secrets forwarding.

```ts
import type { FileCheckFunction, FileFixFunction } from 'declapract';
import { readUseApikeysConfig } from '../../../../../utils/readUseApikeysConfig';

/**
 * .what = builds the expected test.yml content with apikey secrets forwarding
 * .why = single source of truth for both check and fix
 */
const buildExpectedContent = (
  input: { template: string; apikeys: string[] },
): string => {
  let result = input.template;

  // if no apikeys, return template as-is
  if (!input.apikeys.length) {
    return result;
  }

  // build secrets forwarding block
  const secretsForward = input.apikeys
    .map((key) => `      ${key}: \${{ secrets.${key} }}`)
    .join('\n');

  // find jobs that call .test.yml and add secrets block after 'with:' or 'uses:'
  const jobPattern = /(uses: \.\/\.github\/workflows\/\.test\.yml\n(?:    with:\n(?:      [^\n]+\n)*)?)(\n    [a-z]|\n  [a-z]|\n\n|\s*$)/g;

  result = result.replace(jobPattern, (match, beforePart, afterPart) => {
    return `${beforePart}    secrets:\n${secretsForward}${afterPart}`;
  });

  return result;
};

/**
 * .what = ensures test.yml matches expected content with apikey secrets forwarding
 * .why = enables the reusable workflow to access github secrets
 */
export const check: FileCheckFunction = async (contents, context) => {
  const apikeysConfig = await readUseApikeysConfig({
    projectRootDirectory: context.getProjectRootDirectory(),
  });

  const expected = buildExpectedContent({
    template: context.declaredFileContents ?? '',
    apikeys: apikeysConfig?.apikeys?.required ?? [],
  });

  if (contents === expected) {
    throw new Error('file matches expected content');
  }
};

export const fix: FileFixFunction = async (contents, context) => {
  const apikeysConfig = await readUseApikeysConfig({
    projectRootDirectory: context.getProjectRootDirectory(),
  });

  const expected = buildExpectedContent({
    template: context.declaredFileContents ?? '',
    apikeys: apikeysConfig?.apikeys?.required ?? [],
  });

  return { contents: expected };
};
```

**tests:**
- unit test: check throws when no apikeys required
- unit test: check throws when all secrets passed
- unit test: check returns when secrets missing
- unit test: fix adds missing secret forwards
- unit test: fix preserves existing secrets
- integration test: works with actual use.apikeys.json file

#### 4.2 create `src/practices/cicd-package/best-practice/.github/workflows/publish.yml.declapract.ts`

same pattern as test.yml.declapract.ts - finds jobs that call `.test.yml` and ensures secrets are passed.

#### 4.3 create `src/practices/cicd-service/best-practice/.github/workflows/deploy.yml.declapract.ts`

same pattern as test.yml.declapract.ts - finds jobs that call `.test.yml` and ensures secrets are passed.

---

### phase 5: environment variable injection in test jobs

#### 5.1 update `.test.yml` to inject secrets as env vars

the secrets need to be available as environment variables in the test jobs.

update `src/practices/cicd-common/best-practice/.github/workflows/.test.yml` template to include:

```yaml
test-integration:
  runs-on: ubuntu-24.04
  needs: [install]
  env:
    # apikeys will be injected here by declapract fix
  steps:
    # ... existing steps
```

the declapract fix function should:
1. read use.apikeys.json
2. add env block to test-integration job with each secret as env var

```yaml
env:
  ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
```

---

## file structure (final)

```
src/
├── utils/
│   ├── readUseApikeysConfig.ts                    # new
│   └── readUseApikeysConfig.test.ts               # new
├── practices/
│   ├── tests/
│   │   └── bad-practices/
│   │       └── old-apikeys-location/              # new - removes old location
│   │           └── .agent/repo=.this/role=any/skills/
│   │               ├── use.apikeys.json.declapract.ts
│   │               ├── use.apikeys.json.declapract.test.ts
│   │               ├── use.apikeys.sh.declapract.ts
│   │               └── use.apikeys.sh.declapract.test.ts
│   ├── cicd-common/
│   │   └── best-practice/
│   │       ├── .agent/repo=.this/role=any/skills/ # new location
│   │       │   ├── use.apikeys.json               # moved from tests
│   │       │   ├── use.apikeys.json.declapract.ts # moved + updated
│   │       │   ├── use.apikeys.json.declapract.test.ts  # new
│   │       │   ├── use.apikeys.sh                 # moved from tests
│   │       │   └── use.apikeys.sh.declapract.ts   # moved
│   │       └── .github/workflows/
│   │           ├── .test.yml                      # update template
│   │           ├── .test.yml.declapract.ts        # new
│   │           ├── .test.yml.declapract.test.ts   # new
│   │           ├── test.yml                       # update template
│   │           ├── test.yml.declapract.ts         # new
│   │           └── test.yml.declapract.test.ts    # new
│   ├── cicd-package/
│   │   └── best-practice/
│   │       └── .github/workflows/
│   │           ├── publish.yml                    # update template
│   │           ├── publish.yml.declapract.ts      # new
│   │           └── publish.yml.declapract.test.ts # new
│   └── cicd-service/
│       └── best-practice/
│           └── .github/workflows/
│               ├── deploy.yml                     # update template
│               ├── deploy.yml.declapract.ts       # new
│               └── deploy.yml.declapract.test.ts  # new
```

---

## test coverage matrix

| component | unit tests | integration tests |
|-----------|------------|-------------------|
| readUseApikeysConfig | ✓ parse, null, malformed | - |
| old-apikeys-location (bad) | ✓ fix returns null | - |
| use.apikeys.json.declapract | ✓ check exists, fix creates | - |
| .test.yml.declapract | ✓ check missing, fix adds | ✓ with real config |
| test.yml.declapract | ✓ check missing, fix adds | ✓ with real config |
| publish.yml.declapract | ✓ check missing, fix adds | ✓ with real config |
| deploy.yml.declapract | ✓ check missing, fix adds | ✓ with real config |

**acceptance tests:**
- run `npx declapract check` on a repo with use.apikeys.json containing `["ANTHROPIC_API_KEY"]`
- verify .test.yml declares the secret
- verify test.yml passes the secret
- verify old location files are flagged for removal

---

## detailed unit test specifications

### .test.yml.declapract.test.ts

#### test: buildExpectedContent adds secrets declaration

```ts
it('should add secrets declaration to workflow_call', () => {
  const template = `
name: .test

on:
  workflow_call:
    inputs:
      creds-aws-role-arn:
        description: "creds for aws"
        required: false
        type: string

jobs:
  test-unit:
    runs-on: ubuntu-24.04
`.trim();

  const expected = buildExpectedContent({
    template,
    apikeys: ['ANTHROPIC_API_KEY'],
  });

  expect(expected).toMatchInlineSnapshot(`
name: .test

on:
  workflow_call:
    inputs:
      creds-aws-role-arn:
        description: "creds for aws"
        required: false
        type: string
    secrets:
      ANTHROPIC_API_KEY:
        description: "api key for ANTHROPIC_API_KEY"
        required: false

jobs:
  test-unit:
    runs-on: ubuntu-24.04
`);
});
```

#### test: buildExpectedContent adds multiple secrets

```ts
it('should add multiple secrets when multiple required', () => {
  const template = `
name: .test

on:
  workflow_call:

jobs:
  test-unit:
    runs-on: ubuntu-24.04
`.trim();

  const expected = buildExpectedContent({
    template,
    apikeys: ['ANTHROPIC_API_KEY', 'OPENAI_API_KEY'],
  });

  expect(expected).toContain('ANTHROPIC_API_KEY:');
  expect(expected).toContain('OPENAI_API_KEY:');
  expect(expected).toMatchSnapshot();
});
```

#### test: buildExpectedContent adds env vars to test-integration job

```ts
it('should add env vars to test-integration job', () => {
  const template = `
name: .test

on:
  workflow_call:

jobs:
  test-integration:
    runs-on: ubuntu-24.04
    needs: [install]
    steps:
      - name: test:integration
        run: npm run test:integration
`.trim();

  const expected = buildExpectedContent({
    template,
    apikeys: ['ANTHROPIC_API_KEY'],
  });

  expect(expected).toContain('env:');
  expect(expected).toContain('ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}');
  expect(expected).toMatchSnapshot();
});
```

#### test: buildExpectedContent returns template unchanged when no apikeys

```ts
it('should return template unchanged when no apikeys', () => {
  const template = `
name: .test

on:
  workflow_call:

jobs:
  test-unit:
    runs-on: ubuntu-24.04
`.trim();

  const expected = buildExpectedContent({
    template,
    apikeys: [],
  });

  expect(expected).toEqual(template);
});
```

#### test: check throws when contents match expected

```ts
it('should throw when contents match expected', async () => {
  const template = `name: .test\non:\n  workflow_call:`;
  const expected = buildExpectedContent({ template, apikeys: ['KEY'] });

  const context = mockContext({ template, apikeys: ['KEY'] });

  await expect(check(expected, context)).rejects.toThrow('file matches expected content');
});
```

#### test: check returns when contents differ from expected

```ts
it('should not throw when contents differ from expected (bad practice)', async () => {
  const template = `name: .test\non:\n  workflow_call:`;
  const userContent = `name: .test\non:\n  workflow_call:`;  // missing secrets

  const context = mockContext({ template, apikeys: ['KEY'] });

  await expect(check(userContent, context)).resolves.toBeUndefined();
});
```

#### test: fix returns expected content

```ts
it('should return expected content regardless of user content', async () => {
  const template = `name: .test\non:\n  workflow_call:`;
  const userContent = `totally different content`;

  const context = mockContext({ template, apikeys: ['KEY'] });
  const { contents } = await fix(userContent, context);

  const expected = buildExpectedContent({ template, apikeys: ['KEY'] });
  expect(contents).toEqual(expected);
});
```

---

### test.yml.declapract.test.ts

#### test: buildExpectedContent adds secrets forwarding

```ts
it('should add secrets forwarding to job that calls .test.yml', () => {
  const template = `
name: test

on:
  push:
    branches-ignore:
      - main

jobs:
  suite:
    uses: ./.github/workflows/.test.yml
    with:
      creds-aws-region: us-east-1
`.trim();

  const expected = buildExpectedContent({
    template,
    apikeys: ['ANTHROPIC_API_KEY'],
  });

  expect(expected).toMatchInlineSnapshot(`
name: test

on:
  push:
    branches-ignore:
      - main

jobs:
  suite:
    uses: ./.github/workflows/.test.yml
    with:
      creds-aws-region: us-east-1
    secrets:
      ANTHROPIC_API_KEY: \${{ secrets.ANTHROPIC_API_KEY }}
`);
});
```

#### test: buildExpectedContent adds multiple secrets

```ts
it('should add multiple secrets to job', () => {
  const template = `
name: test

jobs:
  suite:
    uses: ./.github/workflows/.test.yml
`.trim();

  const expected = buildExpectedContent({
    template,
    apikeys: ['ANTHROPIC_API_KEY', 'OPENAI_API_KEY'],
  });

  expect(expected).toContain('ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}');
  expect(expected).toContain('OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}');
});
```

#### test: buildExpectedContent handles multiple jobs calling .test.yml

```ts
it('should add secrets to all jobs that call .test.yml', () => {
  const template = `
name: deploy

jobs:
  test:
    uses: ./.github/workflows/.test.yml
  test-again:
    uses: ./.github/workflows/.test.yml
    needs: [test]
`.trim();

  const expected = buildExpectedContent({
    template,
    apikeys: ['ANTHROPIC_API_KEY'],
  });

  // count occurrences of the secret forwarding
  const matches = expected.match(/ANTHROPIC_API_KEY: \$\{\{ secrets\.ANTHROPIC_API_KEY \}\}/g);
  expect(matches).toHaveLength(2);
});
```

---

### publish.yml.declapract.test.ts

same pattern as test.yml - test `buildExpectedContent` transformation and check/fix contract.

---

### deploy.yml.declapract.test.ts

same pattern as test.yml - test `buildExpectedContent` transformation and check/fix contract.

---

### test helper: mockContext

```ts
/**
 * .what = creates mock context for unit tests
 * .why = isolates check/fix logic from file system
 */
const mockContext = (input: {
  template: string;
  apikeys: string[];
}) => ({
  declaredFileContents: input.template,
  getProjectRootDirectory: () => '/mock/project',
  relativeFilePath: '.github/workflows/.test.yml',
  projectVariables: {},
  projectPractices: [],
  required: true,
} as FileCheckContext);

// readUseApikeysConfig would be mocked to return { apikeys: { required: input.apikeys } }
```

---

## implementation order

1. move `use.apikeys.json` and `use.apikeys.sh` from tests to cicd-common
2. create bad-practice `old-apikeys-location` in tests practice
3. create `src/utils/readUseApikeysConfig.ts` + tests
4. update `use.apikeys.json.declapract.ts` with fix function + tests
5. create `.test.yml.declapract.ts` check + fix + tests
6. create `test.yml.declapract.ts` check + fix + tests
7. create `publish.yml.declapract.ts` check + fix + tests
8. create `deploy.yml.declapract.ts` check + fix + tests
9. update workflow templates with env injection pattern
10. integration tests against example repo
11. acceptance test via `npx declapract check && npx declapract fix`

---

## edge cases

1. **no use.apikeys.json**: file gets created with empty required array (by cicd-common best-practice)
2. **empty required array**: workflow practices are no-op (nothing to add)
3. **malformed use.apikeys.json**: fail gracefully with clear error
4. **existing secrets in yaml**: preserve them, only add missing
5. **yaml comments**: preserve during fix operations
6. **workflow doesn't call .test.yml**: skip secret forwarding check
7. **multiple jobs calling .test.yml**: add secrets to all of them
8. **old location exists**: bad-practice detects and fix deletes the old files

---

## migration path

for existing repos using `tests` practice with apikey files in old location:

1. `npx declapract fix` will:
   - create new files in `cicd-common` location (best-practice)
   - delete old files in `tests` location (bad-practice fix)
2. single declapract run handles full migration

---

## dependencies

- no new dependencies required
- uses string replacement instead of yaml parsing for simplicity and comment preservation

---

## risks and mitigations

| risk | mitigation |
|------|------------|
| user customizations lost on fix | full overwrite is intentional - workflows should match template |
| regex patterns don't match all yaml variants | templates are controlled, patterns tested against known structure |
| circular dependency | readUseApikeysConfig is utility, not practice |
| false positives on check | only trigger when use.apikeys.json exists AND has required keys |
| secrets not inherited | use `secrets: inherit` as fallback pattern |
| migration breaks existing repos | bad-practice cleanly removes old, best-practice creates new |

---

## notes

- the `secrets: inherit` pattern is an alternative that passes all secrets without explicit declaration
- however, explicit declaration is preferred for security (principle of least privilege)
- the fix functions should produce deterministic output for idempotency
- `use.apikeys.sh` path in local usage will change from `.agent/.../skills/use.apikeys.sh` but the path is the same, just owned by different practice
