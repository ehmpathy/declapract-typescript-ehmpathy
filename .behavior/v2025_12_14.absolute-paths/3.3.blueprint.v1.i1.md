# blueprint: absolute paths via `@src` alias

## summary

implement absolute path imports using tsconfig `paths` + `tsc-alias` approach:
- `@src/*` resolves to `src/*`
- works with tsx (dev), tsc (build), and node (runtime via tsc-alias post-processing)

---

## phase 1: update `typescript/best-practice`

### 1.1 update `src/practices/typescript/best-practice/tsconfig.json`

add paths configuration:

```json
{
  "extends": [
    "@tsconfig/strictest/tsconfig.json",
    "@tsconfig/node20/tsconfig.json"
  ],
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@src/*": ["src/*"]
    },
    // ... existing options
  }
}
```

### 1.2 update `src/practices/typescript/best-practice/package.json`

add tsc-alias dependency and update build script:

```json
{
  "devDependencies": {
    "tsc-alias": "@declapract{check.minVersion('1.8.10')}",
    // ... existing deps
  },
  "scripts": {
    "build:compile": "tsc -p ./tsconfig.build.json && tsc-alias -p ./tsconfig.build.json",
    // ... existing scripts
  }
}
```

### 1.3 update `src/practices/typescript/best-practice/.declapract.readme.md`

add documentation explaining the @src path alias:

```md
this bundle defines best practices for tsconfig

namely:
- build vs test config
- default name as test config, so that ide's automatically typecheck test files for you
- strict mode
- absolute imports via @src/* path alias
  - eliminates fragile relative paths (../../..)
  - imports are stable regardless of file location
  - easier refactoring and code navigation
```

---

## phase 2: create bad-practice for relative imports

### 2.1 directory structure

```
src/practices/typescript/bad-practices/relative-imports/
├── src/**/*.ts.declapract.ts       # check and fix logic
├── src/**/*.ts.declapract.test.ts  # unit tests
└── .declapract.readme.md           # description
```

### 2.2 create `src/**/*.ts.declapract.ts`

```ts
import { type FileCheckFunction, type FileFixFunction } from 'declapract';

/**
 * .what = detects relative imports that should use @src alias
 * .why = relative paths are fragile and break when files move
 */

// matches relative imports from src/ that go up directories
// e.g., from '../utils/helper' or '../../domain/objects/User'
const RELATIVE_IMPORT_PATTERN = /from\s+['"](\.\.\/)+(.*?)['"]/g;

// matches relative imports that stay within same directory or go down
// these are acceptable: './helper', './utils/thing'
const SAME_DIR_PATTERN = /from\s+['"]\.\/[^'"]+['"]/g;

export const check: FileCheckFunction = (contents, { projectPath, relativeFilePath }) => {
  if (!contents) throw new Error('does not match bad practice');

  // skip if file is not in src/
  if (!relativeFilePath?.startsWith('src/')) {
    throw new Error('does not match bad practice');
  }

  // check for relative imports that go up directories (../)
  const matches = contents.match(RELATIVE_IMPORT_PATTERN);
  if (matches && matches.length > 0) {
    return; // matches bad practice
  }

  throw new Error('does not match bad practice');
};

export const fix: FileFixFunction = (contents, { relativeFilePath }) => {
  if (!contents) return {};
  if (!relativeFilePath?.startsWith('src/')) return {};

  // calculate the depth of the current file from src/
  const pathParts = relativeFilePath.split('/');
  const srcIndex = pathParts.indexOf('src');
  const depthFromSrc = pathParts.length - srcIndex - 2; // -2 for src/ and filename

  // replace relative imports with @src imports
  const fixed = contents.replace(
    /from\s+['"]((\.\.\/)+)(.*?)['"]/g,
    (match, dots, _, path) => {
      // count how many ../ we have
      const upCount = (dots.match(/\.\.\//g) || []).length;

      // calculate the target path from src/
      const currentDirParts = pathParts.slice(srcIndex + 1, -1); // dirs between src/ and file
      const remainingParts = currentDirParts.slice(0, -upCount); // go up
      const targetPath = [...remainingParts, path].join('/');

      // if going all the way up to src/, use @src
      if (upCount >= currentDirParts.length) {
        return `from '@src/${path}'`;
      }

      // otherwise construct the @src path
      return `from '@src/${targetPath}'`;
    }
  );

  return { contents: fixed };
};
```

### 2.3 create `src/**/*.ts.declapract.test.ts`

```ts
import { check, fix } from './*.ts.declapract';

describe('relative-imports bad practice', () => {
  const context = (relativeFilePath: string) => ({
    projectPath: '/project',
    relativeFilePath,
  } as any);

  describe('check', () => {
    it('should match files with relative imports going up directories', () => {
      const contents = `import { helper } from '../utils/helper';`;
      expect(() => check(contents, context('src/domain/objects/User.ts'))).not.toThrow();
    });

    it('should match files with deeply nested relative imports', () => {
      const contents = `import { Config } from '../../../utils/config/getConfig';`;
      expect(() => check(contents, context('src/domain/objects/nested/User.ts'))).not.toThrow();
    });

    it('should not match files with only same-directory imports', () => {
      const contents = `import { helper } from './helper';`;
      expect(() => check(contents, context('src/utils/index.ts'))).toThrow('does not match bad practice');
    });

    it('should not match files with @src imports', () => {
      const contents = `import { helper } from '@src/utils/helper';`;
      expect(() => check(contents, context('src/domain/User.ts'))).toThrow('does not match bad practice');
    });

    it('should not match files outside src/', () => {
      const contents = `import { helper } from '../utils/helper';`;
      expect(() => check(contents, context('acceptance/test.ts'))).toThrow('does not match bad practice');
    });
  });

  describe('fix', () => {
    it('should replace ../utils with @src/utils', async () => {
      const contents = `import { helper } from '../utils/helper';`;
      const { contents: fixed } = await fix(contents, context('src/domain/User.ts'));
      expect(fixed).toBe(`import { helper } from '@src/utils/helper';`);
    });

    it('should replace deeply nested relative imports', async () => {
      const contents = `import { Config } from '../../utils/config/getConfig';`;
      const { contents: fixed } = await fix(contents, context('src/domain/objects/User.ts'));
      expect(fixed).toBe(`import { Config } from '@src/utils/config/getConfig';`);
    });

    it('should handle multiple relative imports', async () => {
      const contents = `import { helper } from '../utils/helper';
import { Config } from '../../utils/config/getConfig';`;
      const { contents: fixed } = await fix(contents, context('src/domain/objects/User.ts'));
      expect(fixed).toContain("from '@src/utils/helper'");
      expect(fixed).toContain("from '@src/utils/config/getConfig'");
    });

    it('should preserve same-directory imports', async () => {
      const contents = `import { helper } from './helper';
import { other } from '../utils/other';`;
      const { contents: fixed } = await fix(contents, context('src/domain/User.ts'));
      expect(fixed).toContain("from './helper'");
      expect(fixed).toContain("from '@src/utils/other'");
    });
  });
});
```

### 2.4 create `.declapract.readme.md`

```md
this bad practice flags relative imports that traverse up directories (../) within src/

why it's bad:
- relative paths break when files are moved
- deep nesting leads to fragile import chains (../../../..)
- harder to understand where imports come from

the fix:
- replace relative imports with @src/* absolute imports
- @src/* maps to src/* via tsconfig paths
- imports become location-independent and self-documenting

example:
- bad:  `import { x } from '../../utils/helper'`
- good: `import { x } from '@src/utils/helper'`
```

---

## note: useCases.yml

the typescript practice is already included in `typescript-project` use-case, so no changes needed. the bad-practice will automatically apply to all projects using the typescript practice.

---

## implementation order

1. **phase 1 first**: update typescript/best-practice
   - add paths to tsconfig.json
   - add tsc-alias to package.json

2. **phase 2 second**: create bad-practice for relative imports
   - implement check and fix logic
   - add unit tests

---

## verification

after implementation, run:
```bash
npm run test:unit
npm run test:validate
npm run build
```

---

## edge cases to consider

1. **test files**: relative imports in test files that reference test utilities might be acceptable
2. **external packages**: ensure pattern doesn't match node_modules imports
3. **dynamic imports**: `import()` syntax should also be handled
4. **require statements**: commonjs `require('../...')` should also be caught
5. **type imports**: `import type { X } from '../...'` should be handled

---

## future considerations

- could add eslint rule to enforce @src usage (e.g., `eslint-plugin-import` with custom resolver)
- could add husky pre-commit hook to prevent new relative imports
- could eventually migrate to node.js subpath imports (`#src`) when tooling stabilizes
