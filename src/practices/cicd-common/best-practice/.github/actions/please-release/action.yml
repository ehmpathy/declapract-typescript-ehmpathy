name: please-release
description: upsert release pr or cutta release tag

inputs:
  github-token:
    description: token for gh cli calls
    required: true
  commit-message:
    description: the head commit message
    required: true
  commit-sha:
    description: the head commit sha
    required: true
  repository:
    description: the repository (owner/repo)
    required: true

outputs:
  action:
    description: what action was taken (noop, created, updated, released)
    value: ${{ steps.result.outputs.action }}
  version:
    description: the computed or released version
    value: ${{ steps.result.outputs.version }}
  pr-number:
    description: the release pr number
    value: ${{ steps.result.outputs.pr-number }}

runs:
  using: "composite"
  steps:
    # step 1: cutta tag, if release commit
    - name: cutta tag, if release commit
      id: cutta
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
      run: |
        COMMIT_MSG="${{ inputs.commit-message }}"
        REPO_URL="https://github.com/${{ inputs.repository }}"

        # check if this is a release commit
        if [[ "$COMMIT_MSG" != chore\(release\):* ]]; then
          echo "did-cutta=false" >> $GITHUB_OUTPUT
          exit 0
        fi

        # extract version from commit message
        VERSION=$(echo "$COMMIT_MSG" | sed -n 's/^chore(release): \(v[0-9.]*\).*/\1/p')

        # failfast if version not found
        if [ -z "$VERSION" ]; then
          echo "::error::could not extract version from commit message: $COMMIT_MSG"
          exit 1
        fi

        # find the release pr that was merged (by head branch, not search - avoids indexing delay)
        PR_NUMBER=$(gh pr list --state merged --head "release/${VERSION}" --json number --jq '.[0].number')

        # failfast if release pr not found
        if [ -z "$PR_NUMBER" ]; then
          echo "::error::could not find merged release pr for version: $VERSION"
          exit 1
        fi

        # create and push tag
        git tag "$VERSION"
        git push origin "$VERSION"

        # create github release
        RELEASE_URL=$(gh release create "$VERSION" \
          --title "$VERSION" \
          --generate-notes \
          --latest)

        # comment on the release pr
        gh pr comment "$PR_NUMBER" --body "released at ${RELEASE_URL}"

        # extract pr links from the release pr body and comment on each
        PR_BODY=$(gh pr view "$PR_NUMBER" --json body --jq '.body')
        REFERENCED_PRS=$(echo "$PR_BODY" | grep -oE '\[#[0-9]+\]\([^)]+/pull/([0-9]+)\)' | grep -oE '[0-9]+' || true)

        for REF_PR in $REFERENCED_PRS; do
          gh pr comment "$REF_PR" --body "released at ${RELEASE_URL}" 2>/dev/null || true
        done

        echo "did-cutta=true" >> $GITHUB_OUTPUT
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "action=released" >> $GITHUB_OUTPUT

    # step 2: crunch future semver, if other commit
    #
    # version resolution strategy:
    #   1. if latest-pkg-version > latest-tag-version: user has manually bumped, use package.json version as-is
    #   2. otherwise: auto-compute next version from max(latest-pkg-version, latest-tag-version) based on conventional commits
    #
    # this lets users manually control versions when needed (e.g., major releases, pre-releases)
    # while still providing automatic semver bumping for typical workflows
    #
    - name: crunch future semver, if other commit
      id: semver
      if: ${{ steps.cutta.outputs.did-cutta == 'false' }}
      shell: bash
      run: |
        # get versions from both sources
        LATEST_PKG_VERSION=$(jq -r '.version' package.json)
        LATEST_TAG_VERSION=$(git describe --tags --abbrev=0 2>/dev/null | sed 's/^v//' || echo "0.0.0")

        # helper: compare semver (returns 0 if $1 > $2, 1 otherwise)
        version_gt() {
          [ "$(printf '%s\n%s' "$1" "$2" | sort -V | tail -n1)" = "$1" ] && [ "$1" != "$2" ]
        }

        # case 1: package.json > tag means user manually set the version
        # respect user intent and use package.json version directly (no auto-bump)
        if version_gt "$LATEST_PKG_VERSION" "$LATEST_TAG_VERSION"; then
          echo "next-version=v${LATEST_PKG_VERSION}" >> $GITHUB_OUTPUT
          echo "current-tag=v${LATEST_TAG_VERSION}" >> $GITHUB_OUTPUT
          exit 0
        fi

        # case 2: auto-compute next version from the greater of tag vs package.json
        # (handles edge cases like tag existing but package.json being behind)
        if version_gt "$LATEST_TAG_VERSION" "$LATEST_PKG_VERSION"; then
          BASE_VERSION="$LATEST_TAG_VERSION"
        else
          BASE_VERSION="$LATEST_PKG_VERSION"
        fi

        # handle first release
        if [ "$BASE_VERSION" = "0.0.0" ]; then
          echo "next-version=v0.1.0" >> $GITHUB_OUTPUT
          echo "current-tag=v0.0.0" >> $GITHUB_OUTPUT
          exit 0
        fi

        # get commits since last release commit
        COMMITS=$(git log --pretty=format:"%s" | sed '/^chore(release):/q' | head -n -1)

        # determine bump type
        BUMP="patch"  # default

        if echo "$COMMITS" | grep -qE "^break(\(.+\))?:"; then
          BUMP="major"
        elif echo "$COMMITS" | grep -qE "^feat(\(.+\))?:"; then
          BUMP="minor"
        fi

        # compute next version
        IFS='.' read -r MAJOR MINOR PATCH <<< "$BASE_VERSION"

        case $BUMP in
          major) NEXT_VERSION="v$((MAJOR + 1)).0.0" ;;
          minor) NEXT_VERSION="v${MAJOR}.$((MINOR + 1)).0" ;;
          patch) NEXT_VERSION="v${MAJOR}.${MINOR}.$((PATCH + 1))" ;;
        esac

        echo "next-version=$NEXT_VERSION" >> $GITHUB_OUTPUT
        echo "current-tag=v${BASE_VERSION}" >> $GITHUB_OUTPUT

    # step 3: crunch future changelog, if other commit
    - name: crunch future changelog, if other commit
      id: changelog
      if: ${{ steps.cutta.outputs.did-cutta == 'false' }}
      shell: bash
      run: |
        REPO_URL="https://github.com/${{ inputs.repository }}"
        PREV_TAG="${{ steps.semver.outputs.current-tag }}"
        NEXT_TAG="${{ steps.semver.outputs.next-version }}"
        TODAY=$(date +%Y-%m-%d)

        # get commits since last release commit (more reliable than tags)
        COMMITS_SINCE_LAST_RELEASE=$(git log --pretty=format:"%H %cs %s" | sed '/chore(release):/q' | head -n -1)

        # group commits by type (hash, date, subject)
        FEATS=$(echo "$COMMITS_SINCE_LAST_RELEASE" | grep -E "^[a-f0-9]+ [0-9-]+ feat(\(.+\))?:" || true)
        FIXES=$(echo "$COMMITS_SINCE_LAST_RELEASE" | grep -E "^[a-f0-9]+ [0-9-]+ fix(\(.+\))?:" || true)
        BREAKS=$(echo "$COMMITS_SINCE_LAST_RELEASE" | grep -E "^[a-f0-9]+ [0-9-]+ break(\(.+\))?:" || true)

        # format changelog - write to temp file to avoid yaml parsing issues with multiline strings
        CHANGELOG_FILE="/tmp/changelog.md"
        echo "## [${NEXT_TAG#v}](${REPO_URL}/compare/${PREV_TAG}...${NEXT_TAG}) (${TODAY})" > "$CHANGELOG_FILE"

        format_commits() {
          local commits="$1"
          while IFS= read -r line; do
            [ -z "$line" ] && continue
            HASH="${line%% *}"
            REST="${line#* }"
            DATE="${REST%% *}"
            COMMIT_MESSAGE="${REST#* }"
            SHORT_HASH="${HASH:0:7}"
            # extract pr number from message if present
            PR_NUM=$(echo "$COMMIT_MESSAGE" | grep -oE '\(#[0-9]+\)' | head -1 | tr -d '(#)')
            echo "&nbsp;&nbsp;○ ${COMMIT_MESSAGE}"
            if [ -n "$PR_NUM" ]; then
              echo "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;├── ${DATE}"
              echo "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;├── [#${PR_NUM}](${REPO_URL}/pull/${PR_NUM})"
              echo "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└── [${SHORT_HASH}](${REPO_URL}/commit/${HASH})"
            else
              echo "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;├── ${DATE}"
              echo "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└── [${SHORT_HASH}](${REPO_URL}/commit/${HASH})"
            fi
            echo ""
          done <<< "$commits"
        }

        if [ -n "$BREAKS" ]; then
          { echo ""; echo "### breaks"; echo ""; format_commits "$BREAKS"; } >> "$CHANGELOG_FILE"
        fi
        if [ -n "$FEATS" ]; then
          { echo ""; echo "### feats"; echo ""; format_commits "$FEATS"; } >> "$CHANGELOG_FILE"
        fi
        if [ -n "$FIXES" ]; then
          { echo ""; echo "### fixes"; echo ""; format_commits "$FIXES"; } >> "$CHANGELOG_FILE"
        fi

        echo "changelog-file=$CHANGELOG_FILE" >> $GITHUB_OUTPUT

    # step 4: upsert release pr, if other commit
    - name: upsert release pr, if other commit
      id: upsert
      if: ${{ steps.cutta.outputs.did-cutta == 'false' }}
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
      run: |
        NEXT_VERSION="${{ steps.semver.outputs.next-version }}"
        CHANGELOG=$(cat "${{ steps.changelog.outputs.changelog-file }}")

        # failfast if package.json doesnt exist
        if [ ! -f package.json ]; then
          echo "::error::package.json not found"
          exit 1
        fi

        REPO="${{ inputs.repository }}"

        # find existing release pr by title pattern
        EXISTING_PR=$(gh pr list --state open --search "chore(release):" --json number,headRefName --jq '.[0]')

        # build pr body in temp file to avoid yaml parsing issues
        PR_BODY_FILE="/tmp/pr-body.md"
        echo "noice! ready to let these changes ride?" > "$PR_BODY_FILE"
        echo "---" >> "$PR_BODY_FILE"
        echo "" >> "$PR_BODY_FILE"
        cat "${{ steps.changelog.outputs.changelog-file }}" >> "$PR_BODY_FILE"
        PR_BODY=$(cat "$PR_BODY_FILE")

        # helper: create verified commit via graphql api (auto-signed by github)
        create_verified_commit() {
          local branch="$1"
          local head_oid="$2"
          local message="$3"

          # update package.json version locally (skip if already at target)
          CURRENT_VERSION=$(jq -r '.version' package.json)
          if [ "$CURRENT_VERSION" != "${NEXT_VERSION#v}" ]; then
            npm version "${NEXT_VERSION#v}" --no-git-tag-version --ignore-scripts
          fi

          # build graphql request with jq
          REQUEST=$(jq -n \
            --arg repo "$REPO" \
            --arg branch "$branch" \
            --arg oid "$head_oid" \
            --arg msg "$message" \
            --arg pkg_content "$(base64 -w0 package.json)" \
            '{
              query: "mutation($input: CreateCommitOnBranchInput!) { createCommitOnBranch(input: $input) { commit { oid } } }",
              variables: {
                input: {
                  branch: { repositoryNameWithOwner: $repo, branchName: $branch },
                  message: { headline: $msg },
                  fileChanges: { additions: [{ path: "package.json", contents: $pkg_content }] },
                  expectedHeadOid: $oid
                }
              }
            }')

          # create commit via graphql (auto-verified!)
          echo "$REQUEST" | gh api graphql --input - --jq '.data.createCommitOnBranch.commit.oid'
        }

        if [ -n "$EXISTING_PR" ] && [ "$EXISTING_PR" != "null" ]; then
          PR_NUMBER=$(echo "$EXISTING_PR" | jq -r '.number')
          BRANCH=$(echo "$EXISTING_PR" | jq -r '.headRefName')

          # get current head and its parent (amend = replace, not stack)
          CURRENT_SHA=$(gh api "repos/${REPO}/git/ref/heads/${BRANCH}" --jq '.object.sha')
          PARENT_SHA=$(gh api "repos/${REPO}/git/commits/${CURRENT_SHA}" --jq '.parents[0].sha')

          # reset branch to parent (for amend behavior)
          gh api "repos/${REPO}/git/refs/heads/${BRANCH}" -X PATCH -f sha="$PARENT_SHA" -F force=true

          # create verified commit on top of parent
          create_verified_commit "$BRANCH" "$PARENT_SHA" "chore(release): ${NEXT_VERSION}"

          # update pr metadata
          gh pr edit "$PR_NUMBER" \
            --title "chore(release): ${NEXT_VERSION}" \
            --body "$PR_BODY"

          echo "action=updated" >> $GITHUB_OUTPUT
          echo "pr-number=$PR_NUMBER" >> $GITHUB_OUTPUT
        else
          BRANCH="release/${NEXT_VERSION}"

          # get main head
          MAIN_SHA=$(gh api "repos/${REPO}/git/ref/heads/main" --jq '.object.sha')

          # create or reset branch to main head
          if gh api "repos/${REPO}/git/ref/heads/${BRANCH}" --jq '.object.sha' 2>/dev/null; then
            gh api "repos/${REPO}/git/refs/heads/${BRANCH}" -X PATCH -f sha="$MAIN_SHA" -F force=true
          else
            gh api "repos/${REPO}/git/refs" -X POST -f ref="refs/heads/${BRANCH}" -f sha="$MAIN_SHA"
          fi

          # create verified commit
          create_verified_commit "$BRANCH" "$MAIN_SHA" "chore(release): ${NEXT_VERSION}"

          # create pr
          PR_URL=$(gh pr create \
            --title "chore(release): ${NEXT_VERSION}" \
            --body "$PR_BODY" \
            --base main \
            --head "$BRANCH")

          PR_NUMBER=$(echo "$PR_URL" | grep -oE '[0-9]+$')

          echo "action=created" >> $GITHUB_OUTPUT
          echo "pr-number=$PR_NUMBER" >> $GITHUB_OUTPUT
        fi

        echo "version=$NEXT_VERSION" >> $GITHUB_OUTPUT

    # step 5: aggregate outputs
    - name: aggregate outputs
      id: result
      if: always()
      shell: bash
      run: |
        if [ "${{ steps.cutta.outputs.did-cutta }}" = "true" ]; then
          echo "action=${{ steps.cutta.outputs.action }}" >> $GITHUB_OUTPUT
          echo "version=${{ steps.cutta.outputs.version }}" >> $GITHUB_OUTPUT
        else
          echo "action=${{ steps.upsert.outputs.action }}" >> $GITHUB_OUTPUT
          echo "version=${{ steps.upsert.outputs.version }}" >> $GITHUB_OUTPUT
          echo "pr-number=${{ steps.upsert.outputs.pr-number }}" >> $GITHUB_OUTPUT
        fi
