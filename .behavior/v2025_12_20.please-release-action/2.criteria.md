# scope.semver = compute next semver from conventional commits

## scope.semver.strategy = version resolution prioritizes user intent

the version resolution strategy enables both automatic and manual version control:

1. if latest-package-version > latest-release-version:
   - user has manually bumped the version in package.json AFTER the last release commit
   - use latest-package-version as-is (no auto-bump)
   - this enables manual control for major releases, pre-releases, or version jumps

2. otherwise:
   - auto-compute next version from max(latest-gittag-version, latest-package-version) based on conventional commits
   - this handles typical workflows where versions are managed automatically
   - note: if latest-package-version == latest-release-version, that version was set by automation, not user

this lets package.json be the source of truth while still providing automatic semver bumping

## scope.semver.usecase.manual-bump = respect manual version bumps

given(latest-package-version is 2.0.0 and latest-release-version is 1.5.0)
  when(we compute next semver)
    then(the next version should be v2.0.0)
      sothat(users can manually control major releases or version jumps)

## scope.semver.usecase.automation-bump = auto-bump when pkg matches release commit

given(latest-package-version is 0.47.0 and latest-release-version is 0.47.0 and latest-gittag-version is 0.46.14)
  when(we compute next semver)
    then(the next version should be v0.47.1 based on conventional commits)
      sothat(versions set by release automation are auto-bumped, not treated as manual bumps)

## scope.semver.usecase.patch = fix commits bump patch

given(a repository with a latest tag of v1.2.3)
  when(we compute next semver)
    and(all commits since last tag are fix: or fix(scope): commits)
      then(the next version should be v1.2.4)
        sothat(patch version reflects backwards-compatible fixes)

## scope.semver.usecase.minor = feat commits bump minor

given(a repository with a latest tag of v1.2.3)
  when(we compute next semver)
    and(any commit since last tag is a feat: or feat(scope): commit)
      then(the next version should be v1.3.0)
        sothat(minor version reflects new functionality)

## scope.semver.usecase.major = breaking changes bump major

given(a repository with a latest tag of v1.2.3)
  when(we compute next semver)
    and(any commit since last tag starts with break: or break(scope):)
      then(the next version should be v2.0.0)
        sothat(major version signals breaking changes to consumers)

## scope.semver.usecase.precedence = major > minor > patch

given(a repository with mixed commit types since last tag)
  when(we compute next semver)
    then(breaking change takes precedence over feat)
    then(feat takes precedence over fix)
      sothat(the highest-impact change determines the version bump)

## scope.semver.usecase.first-release = no tags means v0.1.0

given(a repository with no git tags)
  when(we compute next semver)
    then(the next version should be v0.1.0)
      sothat(new packages start at a sensible version instead of v1.0.0)

## scope.semver.usecase.default-patch = non-bump commits default to patch

given(a repository with commits that are not feat:, fix:, or break:)
  when(we compute next semver)
    then(those commits should be treated as patch-level changes)
      sothat(commits like doc:, refactor:, chore:, test:, or non-conventional commits still trigger a release)


# scope.changelog = compute changelog from commits since last tag

## scope.changelog.usecase.grouping = commits grouped by type

given(commits since last tag include feat: and fix: commits)
  when(we generate the changelog)
    then(features should be grouped under "### feats")
    then(fixes should be grouped under "### fixes")
      sothat(changes are organized by impact type)

## scope.changelog.usecase.pr-links = PR references become links

given(commits with PR references like "(#123)")
  when(we generate the changelog)
    then(PR references should be converted to full github issue links)
      sothat(the changelog is navigable on github)

## scope.changelog.usecase.commit-links = commit hashes become links

given(commits in the changelog)
  when(we generate the changelog)
    then(commit hashes should be converted to full github commit links)
      sothat(each change is traceable to its source)

## scope.changelog.usecase.header = version header with compare link

given(a new version to be released)
  when(we generate the changelog)
    then(the header should include a compare link between old and new tag)
    then(the header should include the release date)
      sothat(the full diff is accessible)


# scope.upsert-pr = upsert a release PR on non-release commits

## scope.upsert-pr.usecase.create = create PR when none exists

given(a repository with no open release PR)
  when(a non-release commit is merged to main)
    then(a new release PR should be created)
      with(status OPEN)
      with(label purpose=release)
      with(label release={computed-semver} per scope.semver)
      with(title "chore(release): v{version} üéâ")
      with(description per scope.changelog + intro line)
        sothat(pending changes are queued for release)

## scope.upsert-pr.usecase.update = update PR when exists

given(a repository with an open release PR)
  when(a non-release commit is merged to main)
    then(the existing release PR should be updated)
      with(release label set to recomputed semver per scope.semver)
      with(title updated to reflect new version)
      with(description updated with new changelog per scope.changelog)
        sothat(the PR always reflects the current pending release)

## scope.upsert-pr.usecase.description-format = PR description follows format

given(a release PR to be created or updated)
  when(we generate the description)
    then(the first line should be "üê¢ noice! ready to let these changes ride?")
    then(there should be a horizontal rule separator)
    then(the changelog per scope.changelog should follow)
      sothat(the PR is friendly and informative)


# scope.cut-tag = cut a release tag on release commits

## scope.cut-tag.usecase.release-commit = tag on chore(release) commit

given(a commit merged to main)
  when(the commit message starts with "chore(release):")
    then(a git tag should be created for the version in the commit message)
    then(a github release should be created for the tag)
      sothat(the release is officially published)

## scope.cut-tag.usecase.no-loop = no PR created for release commits

given(a commit merged to main)
  when(the commit message starts with "chore(release):")
    then(no release PR should be created or updated)
      sothat(we avoid infinite loops of release commits that trigger more releases)

## scope.cut-tag.usecase.comment-release-pr = comment on the release PR

given(a release tag has been successfully created)
  when(the release is published)
    then(a comment should be added to the source release PR)
      with(format "üåä released at {release-url}")
        sothat(contributors are notified of the release)

## scope.cut-tag.usecase.comment-referenced-prs = comment on each PR referenced in the release changelog

given(a release tag has been successfully created)
  and(the release PR's changelog contains PR links per scope.changelog.usecase.pr-links)
    when(the release is published)
      then(a comment should be added to each referenced PR)
        with(format "üåä released at {release-url}")
          sothat(each PR has a link to the release it was included in)


# scope.commitlint = update commitlint config to enforce break: syntax

## scope.commitlint.usecase.allow-break = allow break as a commit type

given(a repository with commitlint configured)
  when(a developer writes a commit with type break: or break(scope):)
    then(commitlint should accept the commit)
      sothat(breaking changes can be declared with the break: prefix)

## scope.commitlint.usecase.forbid-legacy-breaking = forbid BREAKING CHANGE and ! syntax

given(a repository with commitlint configured)
  when(a developer writes a commit with BREAKING CHANGE in the footer)
    then(commitlint should reject the commit)
  when(a developer writes a commit with ! before the colon like feat!:)
    then(commitlint should reject the commit)
      sothat(we enforce a single consistent way to declare breaking changes)
