# blueprint: git-merge-packagejson-autoresolve

## overview

this feature will be implemented as two components:
1. **merge driver package** — collocated under `src/_topublish/` for subsequent npm publication
2. **declapract practice** — a practice that configures repos to use the merge driver

---

## component 1: merge driver package

### package name

`git-merge-packagejson`

### collocation strategy

the package will be developed under `src/_topublish/git-merge-packagejson/` within this repo:
- enables shared toolchain (jest, typescript, biome)
- enables rapid iteration before publication
- will be extracted to its own repo when stable

### directory structure

```
src/_topublish/git-merge-packagejson/
├── src/
│   ├── domain.objects/
│   │   ├── GitMergeInput.ts              # input from git: base, ours, theirs
│   │   ├── DependencySection.ts       # dependencies, devDependencies, etc.
│   │   └── DependencyVersionResolution.ts       # result of version comparison
│   │
│   ├── domain.operations/
│   │   ├── parsePackageJson.ts            # parse json, handle invalid syntax
│   │   ├── extractDependencySections.ts   # extract the 4 dependency sections
│   │   ├── compareVersions.ts             # semver comparison (strip qualifiers)
│   │   ├── detectRemovalIntent.ts         # detect if dep was removed in a branch
│   │   ├── mergeDependencySection.ts      # merge one section with rules
│   │   └── mergePackageJson.ts            # orchestrate full merge
│   │
│   ├── contract/
│   │   └── commands/
│   │       └── merge.ts                   # cli entrypoint: receives %O %A %B %P
│   │
│   └── index.ts                           # public exports
│
├── bin/
│   └── git-merge-packagejson.js           # shebang wrapper for cli
│
├── package.json                           # package manifest (for publication)
├── tsconfig.json                          # extends root tsconfig
└── readme.md                              # package documentation
```

### domain objects

#### GitMergeInput

```ts
interface GitMergeInput {
  base: string;    // %O - common ancestor content
  ours: string;    // %A - current branch content (result goes here)
  theirs: string;  // %B - other branch content
  pathname: string; // %P - file path
}
```

#### DependencySection

```ts
type DependencySectionName =
  | 'dependencies'
  | 'devDependencies'
  | 'peerDependencies'
  | 'optionalDependencies';

interface DependencyEntry {
  name: string;
  version: string;        // original version string (e.g., "^1.2.3")
  versionBase: string;    // stripped version for comparison (e.g., "1.2.3")
}
```

#### DependencyVersionResolution

```ts
interface DependencyVersionResolution {
  action: 'keep-ours' | 'keep-theirs' | 'remove' | 'add';
  dependency: string;
  version: string | null;
  reason: string;
}
```

### domain operations

#### parsePackageJson

```ts
/**
 * .what = parse json content with error context
 * .why = provide clear error messages when branch has invalid json
 */
const parsePackageJson = (input: {
  content: string;
  branch: 'base' | 'ours' | 'theirs';
}): Record<string, unknown>
```

#### stripVersionQualifier

```ts
/**
 * .what = remove ^, ~, >=, etc. from version string for comparison
 * .why = compare base versions while the winner's original format is preserved
 */
const stripVersionQualifier = (input: {
  version: string;
}): { base: string; original: string }
```

#### compareVersions

```ts
/**
 * .what = compare two version strings via semver rules
 * .why = determine which version is higher per semver spec
 */
const compareVersions = (input: {
  versionA: string;
  versionB: string;
}): 'a-higher' | 'b-higher' | 'equal' | 'incomparable'
```

#### detectRemovalIntent

```ts
/**
 * .what = detect if a dependency was removed in one branch
 * .why = honor removal intent per the wish criteria
 */
const detectRemovalIntent = (input: {
  depName: string;
  base: Record<string, string> | undefined;
  ours: Record<string, string> | undefined;
  theirs: Record<string, string> | undefined;
}): { removed: boolean; removedIn: 'ours' | 'theirs' | null }
```

#### mergeDependencySection

```ts
/**
 * .what = merge a single dependency section (e.g., dependencies)
 * .why = apply version selection and removal rules to one section
 */
const mergeDependencySection = (input: {
  sectionName: DependencySectionName;
  base: Record<string, string> | undefined;
  ours: Record<string, string> | undefined;
  theirs: Record<string, string> | undefined;
}): { merged: Record<string, string>; resolutions: DependencyVersionResolution[] }
```

#### mergePackageJson

```ts
/**
 * .what = orchestrate full package.json merge
 * .why = merge all dependency sections and preserve non-dependency fields
 */
const mergePackageJson = (input: {
  base: string;
  ours: string;
  theirs: string;
}): { result: string; hasConflicts: boolean; resolutions: DependencyVersionResolution[] }
```

### merge command (cli entrypoint)

```ts
/**
 * .what = git merge driver entrypoint
 * .why = receives git's %O %A %B %P and writes result to %A
 *
 * exit codes:
 *   0 = merge completed successfully
 *   1 = conflicts remain (non-dependency fields)
 *   >128 = error (invalid json, etc.)
 */
const merge = async (input: {
  baseFile: string;   // %O
  oursFile: string;   // %A (overwrite with result)
  theirsFile: string; // %B
  pathname: string;   // %P
}): Promise<void>
```

---

## component 2: declapract practice

### practice name

`git-merge-packagejson`

### directory structure

```
src/practices/git-merge-packagejson/
├── best-practice/
│   ├── .gitattributes                        # merge driver config
│   ├── .gitattributes.declapract.ts          # check + fix logic
│   ├── .gitattributes.declapract.test.ts     # unit tests
│   ├── package.json                          # dependency declaration
│   └── package.json.declapract.ts            # check + fix logic
│
└── .declapract.readme.md                     # practice documentation
```

### .gitattributes addition

```
# auto-resolve package.json merge conflicts via semver rules
package.json merge=npm-packagejson-merge
```

### git config requirement

the merge driver must be configured in git. options:
1. **global git config** — user runs `npx git-merge-packagejson --install`
2. **repo-level .git/config** — via post-install hook
3. **documentation** — instruct users to configure

recommended: provide an install command that configures git:

```bash
git config merge.npm-packagejson-merge.name "package.json merge driver"
git config merge.npm-packagejson-merge.driver "npx git-merge-packagejson %O %A %B %P"
```

---

## test coverage plan

### unit tests (domain logic)

| file | tests |
|------|-------|
| `stripVersionQualifier.test.ts` | handles ^, ~, >=, <=, =, no qualifier |
| `compareVersions.test.ts` | semver rules, pre-release, non-semver (latest, file:, workspace:) |
| `detectRemovalIntent.test.ts` | removal in ours, theirs, base, no removal |
| `mergeDependencySection.test.ts` | version conflicts, additions, removals, section migrations |
| `parsePackageJson.test.ts` | valid json, invalid json, empty content |

### integration tests (access boundaries)

| file | tests |
|------|-------|
| `mergePackageJson.integration.test.ts` | full 3-way merges with real package.json files |
| `merge.integration.test.ts` | cli entrypoint with temp files |

### end-to-end tests

| file | tests |
|------|-------|
| `merge.e2e.test.ts` | simulate git merge driver invocation |

### acceptance tests (blackbox behaviors)

each usecase from `2.criteria.blackbox.md`:

| usecase | acceptance test |
|---------|-----------------|
| usecase.1 | version conflicts resolve to higher version |
| usecase.2 | additions from both branches are unioned |
| usecase.3 | removals are honored over updates |
| usecase.4 | all dependency sections work independently |
| usecase.5 | non-dependency fields left with conflict markers |
| usecase.6 | edge cases: invalid json, non-semver, workspace protocol |
| usecase.7 | .gitattributes integration works end-to-end |

---

## implementation order

### phase 1: core logic

1. `stripVersionQualifier` + unit tests
2. `compareVersions` + unit tests
3. `detectRemovalIntent` + unit tests
4. `parsePackageJson` + unit tests
5. `mergeDependencySection` + unit tests + integration tests

### phase 2: orchestration

6. `mergePackageJson` + integration tests
7. `merge` command + integration tests

### phase 3: acceptance

8. acceptance tests for all usecases
9. e2e test with real git merge simulation

### phase 4: declapract practice

10. create `git-merge-packagejson` practice
11. add to `useCases.yml` under `typescript-project`

---

## dependencies

### production

- `semver` — version comparison (same as npm uses internally)
- `helpful-errors` — error handle with context

### development

- `test-fns` — given/when/then test structure
- `jest` — test runner

---

## open questions

### [RESOLVED] q1: package location

should the merge driver be:
- **option a**: a separate npm package (e.g., `git-merge-packagejson`)
- **option b**: bundled into this repo as a command

**decision**: collocate under `src/_topublish/git-merge-packagejson/` for development, extract to separate repo for publication when stable

### [RESOLVED] q2: git config installation

how should users configure git?
- **option a**: manual instruction in readme
- **option b**: `npx git-merge-packagejson --install` command
- **option c**: declapract fix adds a husky/prepare hook

**decision**: option b — provide `--install` command that configures git, document in readme

### [RESOLVED] q3: conflict marker behavior

when non-dependency fields conflict, should we:
- **option a**: leave entire file with conflict markers
- **option b**: merge dependency sections and leave markers only in non-dep sections

**decision**: option b — merge dependency sections, leave conflict markers only in non-dep sections for human review

---

## success criteria

the implementation is complete when:
- [ ] all unit tests pass for domain logic
- [ ] all integration tests pass for boundaries
- [ ] all acceptance tests pass for blackbox criteria
- [ ] declapract practice is created and validates
- [ ] users can enable via .gitattributes and git config
- [ ] package.json merge conflicts auto-resolve correctly
